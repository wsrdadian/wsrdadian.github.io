{"meta":{"title":"卡恩思欧的博客","subtitle":"不爱撸猫的摄影师不是好程序猿","description":null,"author":"WSR","url":"https://wsrdadian.github.io"},"pages":[{"title":"categories","date":"2019-01-14T09:15:11.000Z","updated":"2019-01-14T09:15:22.328Z","comments":false,"path":"categories/index.html","permalink":"https://wsrdadian.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-14T09:13:56.000Z","updated":"2019-01-14T09:15:24.920Z","comments":false,"path":"tags/index.html","permalink":"https://wsrdadian.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"定义json数据接口","slug":"定义json数据接口","date":"2019-03-21T07:38:07.000Z","updated":"2019-03-21T08:49:20.898Z","comments":true,"path":"2019/03/21/定义json数据接口/","link":"","permalink":"https://wsrdadian.github.io/2019/03/21/定义json数据接口/","excerpt":"","text":"需求 绘制两点间带箭头的线段，起点终点使用标注标记并点击标注弹出信息窗口。 绘制热力图，根据点坐标及权重（权重越大，点显示越显著）。 添加点击出现弹出框的标注点。 数据 根据函数需要，设计需要传入的参数数据，用json格式写出。 1url?markerInfo=[&#123;&quot;lng&quot;:&quot;116.417854&quot;,&quot;lat&quot;:&quot;39.921988&quot;,&quot;info&quot;:&quot;地址：北京市东城区王府井大街88号乐天银泰百货八层&quot;&#125;,&#123;&quot;lng&quot;:&quot;116.406605&quot;,&quot;lat&quot;:&quot;39.921585&quot;,&quot;info&quot;:&quot;地址：北京市东城区东华门大街&quot;&#125;,&#123;&quot;lng&quot;:&quot;116.412222&quot;,&quot;lat&quot;:&quot;39.912345&quot;,&quot;info&quot;:&quot;地址：北京市东城区正义路甲5号&lt;a href:&apos;../baidu.com&apos;&gt;&lt;/a&gt;&quot;&#125;]&amp;linePoints=[&#123;&quot;lng&quot;:&quot;116.399&quot;,&quot;lat&quot;:&quot;39.930&quot;&#125;,&#123;&quot;lng&quot;:&quot;116.505&quot;,&quot;lat&quot;:&quot;39.950&quot;&#125;]&amp;heatPoints=[&#123;&quot;lng&quot;:&quot;116.405&quot;,&quot;lat&quot;:&quot;39.910&quot;,&quot;count&quot;:&quot;50&quot;&#125;,&#123;&quot;lng&quot;:&quot;116.399&quot;,&quot;lat&quot;:&quot;39.920&quot;,&quot;count&quot;:&quot;51&quot;&#125;] 便于查看，json格式化之后如下（中间脑补 &amp; 符）： 123456789101112131415161718192021222324252627282930313233343536373839markerInfo=[ &#123; &quot;lng&quot;: &quot;116.417854&quot;, &quot;lat&quot;: &quot;39.921988&quot;, &quot;info&quot;: &quot;地址：北京市东城区王府井大街88号乐天银泰百货八层&quot; &#125;, &#123; &quot;lng&quot;: &quot;116.406605&quot;, &quot;lat&quot;: &quot;39.921585&quot;, &quot;info&quot;: &quot;地址：北京市东城区东华门大街&quot; &#125;, &#123; &quot;lng&quot;: &quot;116.412222&quot;, &quot;lat&quot;: &quot;39.912345&quot;, &quot;info&quot;: &quot;地址：北京市东城区正义路甲5号&lt;a href:&apos;../baidu.com&apos;&gt;&lt;/a&gt;&quot; &#125;]linePoints=[ &#123; &quot;lng&quot;: &quot;116.399&quot;, &quot;lat&quot;: &quot;39.930&quot; &#125;, &#123; &quot;lng&quot;: &quot;116.505&quot;, &quot;lat&quot;: &quot;39.950&quot; &#125;]heatPoints=[ &#123; &quot;lng&quot;: &quot;116.405&quot;, &quot;lat&quot;: &quot;39.910&quot;, &quot;count&quot;: &quot;50&quot; &#125;, &#123; &quot;lng&quot;: &quot;116.399&quot;, &quot;lat&quot;: &quot;39.920&quot;, &quot;count&quot;: &quot;51&quot; &#125;] 绘制 获取参数，进行字转义，然后根据 &amp; 进行切割，取到对应的 k=v 对象，然后进行遍历，如果存在相应的 k ，则检查 v 是否符合 json 格式，如果不符合 json 格式，弹出提示框；如果符合，调用对应的创建函数。要保证代码的健壮性，这里对url的格式错误进行提示，同时避免其他参数传入影响接收，在切割字符串时应避免设置固定的数值。 1234567891011121314151617181920212223242526272829303132333435363738394041function getQueryVariable()&#123; var query = decodeURI(window.location.search.substring(1)); console.log(query); if (query.indexOf(&quot;?&quot;)) &#123; query = query.replace(/%22/g,&apos;&quot;&apos;).replace(/%27/g,&apos;&quot;&apos;).replace(/%20/g,&apos; &apos;); //.replace(/%5C/g,&apos;\\\\&apos;).replace(/%3A/g,&apos;:&apos;).replace(/%3B/g,&apos;;&apos;); strs = query.split(&quot;&amp;&quot;); for(var i = 0; i &lt; strs.length; i ++) &#123; var key = strs[i].split(&quot;=&quot;)[0]; var val = unescape(strs[i].split(&quot;=&quot;)[1]); if(key == &apos;heatPoints&apos;) &#123; try&#123; heatPoints = $.parseJSON(val); &#125;catch(err)&#123; alert(&apos;heatPoints参数格式不正确&apos;); break; &#125; addHeat(heatPoints); &#125; if(key == &apos;markerInfo&apos;) &#123; try&#123; markerInfo = $.parseJSON(val); &#125;catch(err)&#123; alert(&apos;markerInfo参数格式不正确&apos;); break; &#125; addMarkerInfo(markerInfo); &#125; if(key == &apos;linePoints&apos;) &#123; try&#123; linePoints = $.parseJSON(val); &#125;catch(err)&#123; alert(&apos;linePoints参数格式不正确&apos;); break; &#125; addLine(linePoints); addMarkerInfo(linePoints); &#125; &#125; &#125;&#125; 绘制两点间的线段，仅需要起点和终点的经纬度即可，创建一条折线，并绘制箭头。 123456function addLine(linePoints)&#123; var points = []; var lineList = new Array();//记录要绘制的线 var arrowLineList = new Array();//记录绘制的箭头线 var isFirstLoad = false;//是否是第一次加载，第一次加载不触发清除事件 var arrowLineLengthRate = 12 / 1;//15是初始时设置的地图显示范围，10是初始时设置的箭头的长度，当地图放大缩小时保证箭头线长度一致 遍历获取经纬度，并创建为一个坐标点 123456for( i = 0; i &lt; linePoints.length; i++ )&#123; var point = linePoints[i]; var lng = point.lng; var lat = point.lat; points[i] = new BMap.Point(lng, lat);&#125; 对折线进行样式设置，设置完成之后，传入点数组，创建折线 123456789101112 var polyline = new BMap.Polyline( points , &#123; strokeWeight:&apos;3&apos;,//折线的宽度，以像素为单位 strokeOpacity: 0.5,//折线的透明度，取值范围0 - 1 strokeColor:&quot;blue&quot; //折线颜色 &#125;); //创建折线 map.addOverlay(polyline); //增加折线 lineList[lineList.length] = polyline;//记录要绘制的线 arrowLineList[arrowLineList.length] = addArrow(polyline,15,Math.PI/7);//记录绘制的箭头线 isFitstLoad = true;//第一次加载&#125; 绘制箭头，箭头的算法有些复杂，自行消化。参考博客：百度地图API绘制带头箭头的折线 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function addArrow(polyline,length,angleValue)&#123; //绘制箭头的函数 var linePoint=polyline.getPath();//线的坐标串 var arrowCount=linePoint.length; for(var i =1;i&lt;arrowCount;i++)&#123; //在拐点处绘制箭头 var pixelStart=map.pointToPixel(linePoint[i-1]); var pixelEnd=map.pointToPixel(linePoint[i]); var angle=angleValue;//箭头和主线的夹角 var r=length; // r/Math.sin(angle)代表箭头长度 var delta=0; //主线斜率，垂直时无斜率 var param=0; //代码简洁考虑 var pixelTemX,pixelTemY;//临时点坐标 var pixelX,pixelY,pixelX1,pixelY1;//箭头两个点 if(pixelEnd.x-pixelStart.x==0)&#123; //斜率不存在是时 pixelTemX=pixelEnd.x; if(pixelEnd.y&gt;pixelStart.y) &#123; pixelTemY=pixelEnd.y-r; &#125; else &#123; pixelTemY=pixelEnd.y+r; &#125; //已知直角三角形两个点坐标及其中一个角，求另外一个点坐标算法 pixelX=pixelTemX-r*Math.tan(angle); pixelX1=pixelTemX+r*Math.tan(angle); pixelY=pixelY1=pixelTemY; &#125; else //斜率存在时 &#123; delta=(pixelEnd.y-pixelStart.y)/(pixelEnd.x-pixelStart.x); param=Math.sqrt(delta*delta+1); if((pixelEnd.x-pixelStart.x)&lt;0) //第二、三象限 &#123; pixelTemX=pixelEnd.x+ r/param; pixelTemY=pixelEnd.y+delta*r/param; &#125; else//第一、四象限 &#123; pixelTemX=pixelEnd.x- r/param; pixelTemY=pixelEnd.y-delta*r/param; &#125; //已知直角三角形两个点坐标及其中一个角，求另外一个点坐标算法 pixelX=pixelTemX+ Math.tan(angle)*r*delta/param; pixelY=pixelTemY-Math.tan(angle)*r/param; pixelX1=pixelTemX- Math.tan(angle)*r*delta/param; pixelY1=pixelTemY+Math.tan(angle)*r/param; &#125; var pointArrow=map.pixelToPoint(new BMap.Pixel(pixelX,pixelY)); var pointArrow1=map.pixelToPoint(new BMap.Pixel(pixelX1,pixelY1)); var Arrow = new BMap.Polyline([ pointArrow, linePoint[i], pointArrow1 ], &#123;strokeColor:&quot;blue&quot;, strokeWeight:5, strokeOpacity:0.5&#125;); map.addOverlay(Arrow); return Arrow; &#125; &#125; 以上为带箭头的折线绘制，这时候可能有人会问， 始末点标注怎么没有创建？其实我一开始是在获取经纬度之后直接创建标注了，但是毕竟后面有创建带信息窗口的标注的需求，何不封装一个创建标注函数，哪里需要就直接调用呢？所以我是把创建标注和窗口这部分单独拿出来了。 创建标注点，点击时弹出信息窗口12345678910111213function addMarkerInfo(markerInfo)&#123; for(i=0;i&lt;markerInfo.length;i++)&#123; var marker = new BMap.Marker(new BMap.Point(markerInfo[i].lng,markerInfo[i].lat)); // 创建标注 map.addOverlay(marker); // 将标注添加到地图中 if(markerInfo[i].info)&#123; info = markerInfo[i].info.replace(/:/g,&quot;=&quot;) addClickHandler(info,marker); console.log(info); &#125;else&#123; markerInfo[i].info = &quot;未添加信息&quot;; addClickHandler(markerInfo[i].info,marker); &#125; &#125; 为标注绑定 click 点击事件 123456function addClickHandler(content,marker)&#123; marker.addEventListener(&quot;onclick&quot;,function(e)&#123; openInfo(content,e)&#125; );&#125; 对窗口进行设置 enableAutoPan 是否支持拖拽后自动移回；enableMessage 是否支持手机短信 1234567var opts = &#123; width : 250, // 信息窗口宽度 height: 80, // 信息窗口高度 title : &quot;信息窗口&quot; , // 信息窗口标题 enableAutoPan: false, enableMessage: false,&#125;; 打开信息窗口，获取被点击的标注经纬度，在该位置创建窗口 1234567 function openInfo(content,e)&#123; var p = e.target; var point = new BMap.Point(p.getPosition().lng, p.getPosition().lat); var infoWindow = new BMap.InfoWindow(content,opts); // 创建信息窗口对象 map.openInfoWindow(infoWindow,point); //开启信息窗口 &#125;&#125; 创建热力图1234567891011121314151617function addHeat(heatPoints)&#123; var heatmapOverlay = new BMapLib.HeatmapOverlay(&#123; &quot;radius&quot;:10, &quot;visible&quot;:true, &quot;opacity&quot;:70 , &quot;gradient&quot;:&#123; 0:&apos;rgba(255, 255, 255, 0.5)&apos;, 0.25:&apos;rgb(0,0,255)&apos;, .5:&apos;rgb(0, 255, 0)&apos;, 0.75:&apos;rgb(255,255,0)&apos;, 1:&apos;rgb(255, 0, 0)&apos; &#125; &#125;); map.addOverlay(heatmapOverlay); var heatPoints = heatPoints; heatmapOverlay.setDataSet(&#123;data:heatPoints,max:100&#125;);&#125; 热力图的点直接传入json字符串即可自动识别，无需获取经纬度后手动创建点，所以热力图这部分代码量较少。 一些小优化 map必须设置高度，否则不显示，所以不能使用流体布局，但是高度又希望自适应，所以最后的想法是获取窗口高度然后赋值给height12height = $(window).height();$(&quot;#map_container&quot;).css(&quot;height&quot;,height); 注意要在map初始化之前完成。 之前使用 window.onload() ,发现绘制图形简直不是一点点的慢，像页面卡住了一样。原来 window.onload() 是页面全部加载完成之后执行，包括图片文件等，这样看来慢是正常的了，所以果断换成DOM加载完成后执行，改为如下： 123$(document).ready(function()&#123; getQueryVariable();&#125;); 去掉图片水印，当然不是需要PS的那种，是在地图图层上的 div 。这个问题困扰我2天了，之前是想用 remove() 去掉，但是必须先渲染出来才能 remove ，所以效果就是先出现一下，然后瞬间被 remove ，但是还是有一瞬间能看见水印，不符合需求。最后实现的想法是，直接给这个 div 加一个 display:none 的 css。之前一直在纠结想从根源上去除，转变一下思路瞬间就解决了，而且还很简单。下次还是要多考虑几个方案。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"百度地图","slug":"百度地图","permalink":"https://wsrdadian.github.io/tags/百度地图/"}]},{"title":"百度地图瓦片相关问题","slug":"百度地图瓦片相关问题","date":"2019-03-15T06:52:02.000Z","updated":"2019-03-15T08:02:51.088Z","comments":true,"path":"2019/03/15/百度地图瓦片相关问题/","link":"","permalink":"https://wsrdadian.github.io/2019/03/15/百度地图瓦片相关问题/","excerpt":"","text":"百度地图的瓦片下载真的是一个巨大的工程量，我下载到15级，瓦片文件已经达到17G，其实还可以更精确一点，但是感觉电脑快跑报废了，而且目前项目要求到15级即可。 瓦片下载工具使用 瓦片下载器不是收费就是有层级限制，在前面的文章 《使用Python离线地图》中，已经使用了一个开源的python工具来下载，但是由于下载下来的瓦片组织性不强，迁移费力，以及merge时出现的内存不够，电脑卡死等问题，不得不重新寻找下载瓦片并保证离线地图能正常使用的方法，经过一个周末终于找到了一个免费的下载器： BaiduMapTile。 进入 BaiduMapTile\\BaiduMapTile\\bin\\Debug\\BaiduMapTile.exe 填写经纬度，瓦片自动下载到 \\BaiduMapTile\\BaiduMapTile\\bin\\Debug\\html\\maptile 目录下，并按照经纬度自动创建文件目录，这次的方式，无需合成瓦片，在显示时，会按照经纬度自动寻找相应的文件目录，显示瓦片。 离线地图使用 瓦片下载完成后，将瓦片文件复制到 BaiduMapTile\\html\\maptile 文件夹中，并按照 map.txt 对apiv2.0_street.js 进行修改，为了避免控制台报错，在 1494 行将 appendChild 去掉，避免生成调用在线API的 head 文件1document.getElementsByTagName(&quot;head&quot;)[0];//.appendChild(d) 百度地图API调用画折线 在百度API文档中下载 CurveLine.js 文件，并引入 1&lt;script type=&quot;text/javascript&quot; src=&quot;js/CurveLine.js&quot;&gt;&lt;/script&gt; 渲染地图，并画一条简单的折线 12345678910111213var map = new BMap.Map(&quot;container&quot;,&#123;mapType: BMAP_NORMAL_MAP&#125;); var point = new BMap.Point(116.404, 39.915); // 创建点坐标 map.centerAndZoom(point,15); // 初始化地图,设置中心点坐标和地图级别。 //map.addControl(new BMap.MapTypeControl()); map.addControl(new BMap.NavigationControl()); map.enableScrollWheelZoom(); // 启用滚轮放大缩小。 map.enableKeyboard(); // 启用键盘操作。 var polyline = new BMap.Polyline([ new BMap.Point(116.399, 39.910), new BMap.Point(116.405, 39.920), new BMap.Point(116.423493, 39.907445) ], &#123;strokeColor:&quot;blue&quot;, strokeWeight:2, strokeOpacity:0.5&#125;); //创建折线map.addOverlay(polyline); //增加折线 热力图 在百度API文档中下载 CurveLine.js 文件，并引入Heatmap.js 1&lt;script type=&quot;text/javascript&quot; src=&quot;js/Heatmap.min.js&quot;&gt;&lt;/script&gt; 创建一些热力点，一般放在JSON文件中调用,例如： 123456var points =[&#123;&quot;lng&quot;:116.418261,&quot;lat&quot;:39.921984,&quot;count&quot;:50&#125;,&#123;&quot;lng&quot;:116.423332,&quot;lat&quot;:39.916532,&quot;count&quot;:51&#125;,&#123;&quot;lng&quot;:116.419787,&quot;lat&quot;:39.930658,&quot;count&quot;:15&#125;,&#123;&quot;lng&quot;:116.418455,&quot;lat&quot;:39.920921,&quot;count&quot;:40&#125;]; 渲染热力图 12345678910111213var heatmapOverlay = new BMapLib.HeatmapOverlay(&#123;&quot;radius&quot;:10, &quot;visible&quot;:true, &quot;opacity&quot;:70 , &quot;gradient&quot;:&#123; 0:&apos;rgba(255, 255, 255, 0.5)&apos;, 0.25:&apos;rgb(0,0,255)&apos;, .5:&apos;rgb(0, 255, 0)&apos;, 0.75:&apos;rgb(255,255,0)&apos;, 1:&apos;rgb(255, 0, 0)&apos;&#125;&#125;);map.addOverlay(heatmapOverlay);heatmapOverlay.setDataSet(&#123;data:points,max:100&#125;); gradient 为热力图点的渐变颜色，radius 每个点的半径，visible 是否展示热力图，opacity 热力的透明度 下一步任务将离线出来的地图封装成一个小工具，数据全部采用Json格式接口调用。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"百度地图","slug":"百度地图","permalink":"https://wsrdadian.github.io/tags/百度地图/"}]},{"title":"React基础学习（一）","slug":"React基础学习（一）","date":"2019-03-13T03:20:57.000Z","updated":"2019-03-15T08:03:36.496Z","comments":true,"path":"2019/03/13/React基础学习（一）/","link":"","permalink":"https://wsrdadian.github.io/2019/03/13/React基础学习（一）/","excerpt":"","text":"在安装 React 之前需要安装 Node 环境和 NPM 环境 安装并运行 安装 1234$ npm install -g create-react-appC:\\Users\\Administrator\\AppData\\Roaming\\npm\\create-react-app -&gt; C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\create-react-app\\index.js+ create-react-app@2.1.8added 63 packages from 20 contributors in 15.223s 创建一个项目 123456789101112131415161718192021222324252627282930313233343536373839$ create-react-app my-new-appCreating a new React app in F:\\web\\react\\my-new-app.Installing packages. This might take a couple of minutes.Installing react, react-dom, and react-scripts...+ react-dom@16.8.4+ react-scripts@2.1.8+ react@16.8.4added 1839 packages from 718 contributors and audited 36232 packages in 301.026sfound 63 low severity vulnerabilities run `npm audit fix` to fix them, or `npm audit` for detailsInitialized a git repository.Success! Created my-new-app at F:\\web\\react\\my-new-appInside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm test Starts the test runner. npm run eject Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back!We suggest that you begin by typing: cd my-new-app npm startHappy hacking! 运行 12345678910111213141516171819$ cd my-new-app/Administrator@KHMD9Q7MXH8OBVI MINGW64 /f/web/react/my-new-app (master)$ npm start&gt; my-new-app@0.1.0 start F:\\web\\react\\my-new-app&gt; react-scripts startStarting the development server...Compiled successfully!You can now view my-new-app in the browser. Local: http://localhost:3000/ On Your Network: http://192.168.1.101:3000/Note that the development build is not optimized.To create a production build, use npm run build. 下一步任务React脚手架安装完成，接下来是完成一个ToDoList练习。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wsrdadian.github.io/tags/React/"}]},{"title":"Metronic学习之路(二)","slug":"Metronic学习之路-二","date":"2019-03-13T01:28:16.000Z","updated":"2019-03-13T03:18:48.585Z","comments":true,"path":"2019/03/13/Metronic学习之路-二/","link":"","permalink":"https://wsrdadian.github.io/2019/03/13/Metronic学习之路-二/","excerpt":"","text":"进行框架搭建基础搭建，进行模块化，保持每个页面局部集中；排除不需要的文件和插件。 思路 假定你在 7 个可用的子主题中选择了 Admin 1(admin_1) 子主题。 这个主题有两个部分. 首先是包含了所有 css、js和第三方插件的 assets 文件夹，接着是包含实际 HTML 模板的模板文件夹。可以参考启动时调用的 theme/assets 和 theme/admin_1。 theme/assets 的 layout 文件夹里你可以发现有 7 个独立的 layout 文件夹（如 layout，layou2, … layout7）,你可以保留你用到的 theme/assets/layouts/layout 和 theme/layouts/global 然后将你用不到的 layout 文件夹删除。 这样在theme/assets/layouts 文件夹里你就只有 theme/assets/layouts/layout 和 theme/assets/layouts/global 两个文件夹了。 theme/admin_1 文件夹在 layout_blank_page.html 打开时被引用。这个模板包括了压缩后的 css、js 和第三方插件。你可以用此模板作为你应用程序的起点。试着将 layout_blank_page.html 的代码分离成模块化(header, sidebar, footer, main content)，并保持每个页面局部集中。 在第三方插件文件夹(theme/assets/global/plugins)，你可以排除你用不到的插件. 默认 Metronic 包括 80 个第三方插件， 大部分主题你不会用到，你可以将他们排除。 参考:Metronic学习之路 模块化参考文章：传统HTML页面实现模块化加载 网站需要模块化的原因 Web前端主流模块化框架的区别","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"Metronic","slug":"Metronic","permalink":"https://wsrdadian.github.io/tags/Metronic/"}]},{"title":"Metronic学习之路(一)","slug":"Metronic学习之路-一","date":"2019-03-12T01:42:47.000Z","updated":"2019-03-12T09:25:21.851Z","comments":true,"path":"2019/03/12/Metronic学习之路-一/","link":"","permalink":"https://wsrdadian.github.io/2019/03/12/Metronic学习之路-一/","excerpt":"","text":"使用GULP构建工具对Metronic进行管理 部署gulp 打开终端并进入到 Metronic 的 theme 根目录，运行以下代码1$ npm install //安装程序的依赖包 发现 npm install 报 node-sass 错误原因: npm install 的时候所下载的 node-sass 文件夹是空的在 C:\\Users\\admin\\AppData\\Roaming\\npm-cache\\node-sass\\3.13.1 下面可以看到解决方法:自己单独用 npm i node-sass 下载一遍会在 C:\\Users\\姓名AppData\\Roaming\\npm-cache\\node-sass\\4.7.2 下面会有一个文件win32-x64-57_binding.node ,把这个文件复制到 3.13.1 下面然后重新 npm install 就解决了 全局安装gulp 1$ npm install gulp -g 测试 gulp，在终端输入 gulp 报错 Cannot find module ‘gulp-prettify’ 模块找不到进入 npm 搜索包名并安装 1$ npm i gulp-prettify 再次执行 gulp 命令 1$ gulp 出现 1234$ gulp[09:53:07] Using gulpfile F:\\web\\metronic_v4.5.2\\theme\\gulpfile.js[09:53:07] Task never defined: default[09:53:07] To list available tasks, try running: gulp --tasks 说明 gulp 部署成功，只是默认任务还没有配置,需要看看 gulpfile.js 列出的其他任务。 如果有其他问题，请参考初探前端自动化神器（Gulp）Bootstrap 之 Metronic 模板的学习之路 - （7）GULP 前端自动化工具 gulp 任务运用gulp localhost 安装 Connect 插件 1npm install--save-dev gulp-connect npm install –save-dev 可以简化为 npm i -D 为 web 服务器定义一个任务， gulpfile.js 文件中添加 123gulp.task(&apos;localhost&apos;, function() &#123; connect.server();&#125;); 只要在终端/命令行中执行 gulp, 就可以启动 web 服务器，然后可以在浏览器中打开 localhost:8080 gulp localhost-live 给 connect.server() 方法传入一个参数12345gulp.task(&apos;localhost-live&apos;, function() &#123; connect.server(&#123; livereload: true &#125;);&#125;); SASS 编译gulp sass打开终端进入到 gulpfile.js 所在的 theme 目录。输入 gulp sass 命令执行手工构建任务。 发现报错 1It&apos;s not clear which file to import for &apos;@import &quot;file&quot;&apos;. 由于 sass _filename.scss 不允许出现 同名无下划线 filename.scss ,写文件全称试试 解决：components-md.scss 中1@import &apos;_components.scss&apos;; 继续执行 gulp sass,发现报错12345Message: sass\\global\\_components.scssError: Import directives may not be used within control directives or mixins. on line 7 of sass/global/_components.scss from line 8 of sass/global/components-md.scss 解决：_components.scss 中 1234// General CSS Reset@if $theme-style == &quot;square&quot; &#123; @import &apos;components/_reset-rounds&apos;;&#125; 去掉 @if 判断 继续执行 gulp sass ,出现新的报错123Error: Undefined variable: &quot;$general-border-radius&quot;. on line 134 of sass/apps/inbox.scss border-radius: $general-border-radius; 解决：global/_variables.scss 中 12345@if $theme-type == &quot;material-design&quot; &#123;$general-border-radius: 2px !default;&#125; @else &#123;$general-border-radius: 4px !default;&#125; 在 @if 前添加 1$general-border-radius: 2px !default; 继续执行 gulp sass ,出现新的报错12The following tasks did not complete: testGulp Did you forget to signal async completion? 官方方法在不使用文件流的情况下，向task的函数里传入一个名叫done的回调函数，以结束task。参考1234gulp.task(&apos;testGulp&apos;, done =&gt; &#123; console.log(&apos;Hello World!&apos;); done();&#125;); gulp sass:watch 输入 gulp sass:watch 运行 scss 实时监控 css 文件的编译，编译后的 css 文件会输出到 assets 目录。12345678Error: watching ./sass/**/*.scss: watch task has to be a function (optionally generated by using gulp.parallel or gulp.series) at Gulp.watch (F:\\web\\metronic_v4.5.2\\theme\\node_modules\\gulp\\index.js:28:11) at F:\\web\\metronic_v4.5.2\\theme\\gulpfile.js:59:10 at taskWrapper (F:\\web\\metronic_v4.5.2\\theme\\node_modules\\undertaker\\lib\\set-task.js:13:15) at bound (domain.js:395:14) at runBound (domain.js:408:12) at asyncRunner (F:\\web\\metronic_v4.5.2\\theme\\node_modules\\async-done\\index.js:55:18) at process._tickCallback (internal/process/next_tick.js:61:11) 分析：这个是由于require引入的包的版本问题导致的。在不同的版本里，接口参数发生了变化。在gulp4.0之后已经只能接受watch第二个参数必须为函数。解决办法：修改gulpfile.js123gulp.task(&apos;sass:watch&apos;, function () &#123; gulp.watch(&apos;./sass/**/*.scss&apos;,gulp.series(&apos;sass&apos;));&#125;); RTL SASS 编译 因为 RTL 的主题文件和默认的主题文件不在同一个目录，一个在 theme_rtl ，一个在 theme，所以，在 theme_rtl 目录下，需要对 gulp 进行重新部署。 然后进入 gulpfile.js 位于的 theme_rtl 目录。确定最新修改的 SCSS 已通过 gulp sass 或 gulp sass:watch 命令编译。运行 gulp rtlcss 命令执行 css 文件的 RTL 版本修改任务。编译后的 RTL css 会被输出到 assets 目录. CSS 和 JS 文件的压缩 在命令行下进入 theme 目录。运行 gulp minify 执行 css 和 js 文件压缩任务.压缩后的文件会输出到 html 目录. HTML 格式化 gulp prettify 该命令可以将 HTML 格式化缩进，对于 pre 和 code 两个标签内的内容不进行格式化。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"Metronic","slug":"Metronic","permalink":"https://wsrdadian.github.io/tags/Metronic/"}]},{"title":"没有密码怎么进入系统","slug":"没有密码怎么进入系统","date":"2019-03-08T02:10:58.000Z","updated":"2019-03-08T02:33:14.974Z","comments":true,"path":"2019/03/08/没有密码怎么进入系统/","link":"","permalink":"https://wsrdadian.github.io/2019/03/08/没有密码怎么进入系统/","excerpt":"","text":"很无脑的操作，只需要一个U启 准备工作 一个U盘启动器（平时用来装系统的，我的是 老友 老毛桃也可以） 查找电脑主机型号所对应的 BOIS 系统进入按键 步骤 进入 BIOS ，选择进入 USB 系统 使用密码破解功能，选择你想破解的用户，或者直接破解管理员 关机重新启动，选择管理员登录（或者使用你修改了密码以后的用户） 登录管理员账户后进入控制面板创建新的账户 关机，登录自己的新账户 总结 千万不要让陌生人的U盘接近自己的电脑 做一个U启随身带着以防不时之需","categories":[{"name":"系统","slug":"系统","permalink":"https://wsrdadian.github.io/categories/系统/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://wsrdadian.github.io/tags/Windows/"}]},{"title":"地图离线之瓦片下载-python+PIL","slug":"使用python离线地图","date":"2019-03-06T01:25:54.000Z","updated":"2019-03-15T06:53:41.862Z","comments":true,"path":"2019/03/06/使用python离线地图/","link":"","permalink":"https://wsrdadian.github.io/2019/03/06/使用python离线地图/","excerpt":"","text":"使用python下载瓦片 环境 python3.7 内置pip，使用比较方便 PIL只支持到 python2.7,在3.7之后，使用 pillow 效果相同1pip install Pillow 代码 github链接 按照md文件进行自定义操作 修改了一些代码 gmap_utils.py 文件中ak值换成自己申请的 download_tiles.py 文件 1234query = &quot;qt=tile&amp;x=%d&amp;y=%d&amp;z=%d&amp;styles=%s%s&amp;udt=20190307&quot; % (x, y, zoom, styles, scaler)url = &quot;http://online0.map.bdimg.com/onlinelabel/?&quot; + querypath = &quot;%d_%d_%d_r&quot; % (zoom ,x, y)filename = path + &quot;.png&quot; merge_tiles.py 文件 由于原代码中文件路径和文件名与该文件中的要求不符，所以修改filename使其符合要求 1filename = &quot;tile/%d_%d_%d_%s.%s&quot; % (zoom, x, y, TYPE, ext) 生成的图片加层级标志 1result.save(&quot;map_%d_%s.%s&quot; % (zoom, TYPE, ext)) 仍然存在的一些问题 请求次数过多时，出现10060错误，目前只是重新获取，应该需要对 REQUEST 进行深入研究 级别过高时，合并图片出现内存溢出错误，初步判断为 python 内存设置问题，需继续研究 若合并时内存问题不能解决，高层级可以先获取省级，再逐个将省级合并为国家级，此时应写出新的 python 的图像合成文件","categories":[{"name":"python","slug":"python","permalink":"https://wsrdadian.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wsrdadian.github.io/tags/python/"},{"name":"PIL","slug":"PIL","permalink":"https://wsrdadian.github.io/tags/PIL/"},{"name":"百度地图","slug":"百度地图","permalink":"https://wsrdadian.github.io/tags/百度地图/"}]},{"title":"使用vue.js2.5+cube-ui仿饿了么APP-项目准备工作","slug":"使用vue-js2-5-cube-ui仿饿了么APP-项目准备工作","date":"2019-01-15T08:31:21.000Z","updated":"2019-01-15T11:46:51.891Z","comments":true,"path":"2019/01/15/使用vue-js2-5-cube-ui仿饿了么APP-项目准备工作/","link":"","permalink":"https://wsrdadian.github.io/2019/01/15/使用vue-js2-5-cube-ui仿饿了么APP-项目准备工作/","excerpt":"","text":"进行项目准备，安装 vue、cube-ui 并测试 api 数据接口。 vue 安装 安装vue-cli 12npm install -g @vue/clivue --version 创建项目 1vue create 项目名 选择相应配置 测试项目是否能够成功运行 12cd 项目名npm run serve 访问 http://localhost:8080/ cube-ui安装 cube-ui的 github地址 作为 vue-cli 插件使用 1vue add cube-ui 进行相关配置 请仔细阅读 vue-cli 和 cube-ui 文档 api接口mock 根目录下添加 ./data.json在项目源码中下载文件，下载方法 在 vue.config.js 中添加代码 1234const appData = require(&apos;./data.json&apos;)const seller = appData.sellerconst goods = appData.goodsconst ratings = appData.ratings pluginOptions后添加 12345678910111213141516171819202122devServer: &#123; before(app) &#123; app.get(&apos;/api/seller&apos;,function(req,res) &#123; res.json(&#123; errno: 0, data: seller &#125;) &#125;) app.get(&apos;/api/goods&apos;,function(req,res) &#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;) app.get(&apos;/api/ratings&apos;,function(req,res) &#123; res.json(&#123; errno: 0, data: ratings &#125;) &#125;) &#125; &#125; 运行程序并访问 http://localhost:8080/api/seller 如果显示json内容则正确 为谷歌浏览器安装 jsonview","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wsrdadian.github.io/tags/vue/"},{"name":"cube-ui","slug":"cube-ui","permalink":"https://wsrdadian.github.io/tags/cube-ui/"}]},{"title":"修改配色为小埋色以及图标制作","slug":"修改配色为小埋色以及图标制作","date":"2019-01-14T12:46:27.000Z","updated":"2019-01-14T13:01:49.960Z","comments":true,"path":"2019/01/14/修改配色为小埋色以及图标制作/","link":"","permalink":"https://wsrdadian.github.io/2019/01/14/修改配色为小埋色以及图标制作/","excerpt":"","text":"修改博客配色为小埋色 , 主色是小埋斗篷颜色 , 部分部件是裤子的颜色 , 大部分文字为黑白. less文件/themes/indigo/source/css/_partical/variable.less1234@darkPrimaryColor: #334432; @primaryColor: #f28135; #主色(小埋色)@lightPrimaryColor: #fcddb7; #发色@textPrimaryColor: #fff; 修改头像背景/themes/indigo/source/img/brand.jpg 图标制作 使用ico在线制作工具将图片转为 .ico 格式 将图片放入 themes/indigo/source/img 文件夹中，并修改 themes/indigo 中_config.xml 中 favicon 为 /img/favicon.ico","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wsrdadian.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://wsrdadian.github.io/tags/blog/"}]},{"title":"使用hexo快速建立属于自己的blog","slug":"如使用hexo何¦何使用hexo快建立blog快速","date":"2019-01-14T11:30:25.000Z","updated":"2019-01-14T12:29:25.287Z","comments":true,"path":"2019/01/14/如使用hexo何¦何使用hexo快建立blog快速/","link":"","permalink":"https://wsrdadian.github.io/2019/01/14/如使用hexo何¦何使用hexo快建立blog快速/","excerpt":"","text":"使用HEXO快速搭建个性化BLOG 环境 使用命令行工具 Git 管理和部署代码 安装 Node 并安装 npm 步骤 注册 github 账号并配置 ssh 在github上新建一个项目,注意项目名为 用户名.github.io 使用npm快速安装 hexo 123hexo init //初始化hexocd hexo //进入项目文件npm install //安装依赖包 安装喜欢的 主题 12git clone 主题的下载地址.gitnpm install 主题插件 此博客风格为 indigo 主题安装完成后对 hexo 的根目录下的 _config.yml 进行修改 1234567891011title: 博客标题subtitle: 副标题description: 网站描述language: 语言url: 站点网址(必填,否则会报错)deploy: type: git repo: ssh网址.git branch: master&lt;!--其他视情况填写即可--&gt; 对主题进行个性化配置,修改主题目录下的 _config.yml 生成网页 , 本地预览 12hexo generatehexo server 本地预览网址: http://localhost:4000 新建 blog 1hexo new &quot;文章标题&quot; 在 source/_posts 目录下会生成文章标题.md 123456title: 文章标题date: 2015-07-30 07:56:29 #发表日期，一般不改动categories: 文章分类tags: [github,hexo] 文章标签---正文，使用Markdown语法书写 部署到 github 的项目上 1hexo deploy 部署成功会提示 1[info] Deploy done: git 访问 https://github用户名.github.io 查看自己的博客 常见问题 提示 Cannot read property ‘replace’ of null 错误 ——–&gt; _config.yml 中 url 未填写导致 代码部署未更新 ——–&gt; hexo clean 后执行 hexo deploy 即可 每次部署都需要输入 github 用户名和密码 ———&gt; 检查 _config.yml 中配置的链接是 ssh 还是 https 链接 自定义的样式无效 ——-&gt; _config.yml 中设置 cdn: false","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wsrdadian.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://wsrdadian.github.io/tags/blog/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-14T08:37:25.599Z","updated":"2019-01-14T08:37:25.599Z","comments":true,"path":"2019/01/14/hello-world/","link":"","permalink":"https://wsrdadian.github.io/2019/01/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
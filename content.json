{"meta":{"title":"王世茹的博客","subtitle":"不爱撸猫的摄影师不是好程序猿","description":null,"author":"WSR","url":"https://wsrdadian.github.io"},"pages":[{"title":"tags","date":"2019-01-14T09:13:56.000Z","updated":"2019-01-14T09:15:24.920Z","comments":false,"path":"tags/index.html","permalink":"https://wsrdadian.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-14T09:15:11.000Z","updated":"2019-01-14T09:15:22.328Z","comments":false,"path":"categories/index.html","permalink":"https://wsrdadian.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"电网demo技术（一）","slug":"电网demo技术（一）","date":"2019-07-15T01:22:16.000Z","updated":"2019-07-15T03:03:50.498Z","comments":true,"path":"2019/07/15/电网demo技术（一）/","link":"","permalink":"https://wsrdadian.github.io/2019/07/15/电网demo技术（一）/","excerpt":"","text":"接口使用 设置地图中心点（随点击标注而变化） 设置地图允许的最小/大级别 设置点的新图标（按type分类） 添加信息图标 给标注绑定事件（瓦片加载、滑动、点击）具体技术参考百度地图官方API，用法已经比较详细 标注和潮流线 标注使用自定义图标，三种类型 潮流线需要表示流向和大小，使用Mapv（baidu-map-forceEdgeBundling）展示，三种类型 部分功能实现思路 DataSet和后端定义好接口 12345678910111213141516171819202122// var pointJson = [// &#123;lng: 112.19678, id: &quot;57&quot;, type: &quot;normal&quot;, lat: 30.9385, info: &quot;湖北荆门变电站&quot;&#125;,// &#123;lng: 118.39869, id: &quot;13&quot;, type: &quot;warning&quot;, lat: 31.35427, info: &quot;安徽芜湖站&quot;&#125;,// &#123;lng: 117.26289, id: &quot;14&quot;, type: &quot;danger&quot;, lat: 31.834887, info: &quot;四川锦西电厂&quot;&#125;// ]// var lineJson = [// &#123;// &quot;sourceid&quot;:&quot;0&quot;,// &quot;targetid&quot;:&quot;1&quot;,// &quot;type&quot;: &apos;normal&apos;// &#125;,// &#123;// &quot;sourceid&quot;:&quot;1&quot;,// &quot;targetid&quot;:&quot;2&quot;,// &quot;type&quot;: &apos;warning&apos;// &#125;,// &#123;// &quot;sourceid&quot;:&quot;2&quot;,// &quot;targetid&quot;:&quot;3&quot;,// &quot;type&quot;: &apos;danger&apos;// &#125;// ] 标注渲染三种类型标注的渲染，注意每创建一个标注，都需要给该标注绑定事件 12345678910111213141516171819202122232425262728293031323334353637383940function addMarkerInfo(markerInfo)&#123; for(i=0;i&lt;markerInfo.length;i++)&#123; if(markerInfo[i].type==&apos;normal&apos;)&#123; var normalMyIcon = new BMap.Icon(&quot;../assets/img/mark/normal/green.png&quot;, new BMap.Size(37,37)); var normalMarker = new BMap.Marker(new BMap.Point(markerInfo[i].lng,markerInfo[i].lat),&#123;icon:normalMyIcon&#125;); // 创建normal标注 map.addOverlay(normalMarker); if($(&quot;#regionLevel&quot;).hasClass(&quot;active&quot;))&#123; addMouseoverHandler(markerInfo[i].id,normalMarker); &#125;else if($(&quot;#stationLevel&quot;).hasClass(&quot;active&quot;))&#123; addMouseoverHandler(markerInfo[i].id,normalMarker); addClickHandler(markerInfo[i].id,normalMarker); &#125; &#125;else if(markerInfo[i].type==&apos;warning&apos;)&#123; var warningMyIcon = new BMap.Icon(&quot;../assets/img/mark/warning/yellow.png&quot;, new BMap.Size(37,37)); var warningMarker = new BMap.Marker(new BMap.Point(markerInfo[i].lng,markerInfo[i].lat),&#123;icon:warningMyIcon&#125;); // 创建warning标注 map.addOverlay(warningMarker); if($(&quot;#regionLevel&quot;).hasClass(&quot;active&quot;))&#123; addMouseoverHandler(markerInfo[i].id,warningMarker); &#125;else if($(&quot;#stationLevel&quot;).hasClass(&quot;active&quot;))&#123; addMouseoverHandler(markerInfo[i].id,warningMarker); addClickHandler(markerInfo[i].id,warningMarker); &#125; &#125;else if(markerInfo[i].type==&apos;danger&apos;)&#123; var dangerMyIcon = new BMap.Icon(&quot;../assets/img/mark/danger/red.png&quot;, new BMap.Size(37,37)); var dangerMarker = new BMap.Marker(new BMap.Point(markerInfo[i].lng,markerInfo[i].lat),&#123;icon:dangerMyIcon&#125;); // 创建danger标注 map.addOverlay(dangerMarker); if($(&quot;#regionLevel&quot;).hasClass(&quot;active&quot;))&#123; addMouseoverHandler(markerInfo[i].id,dangerMarker); &#125;else if($(&quot;#stationLevel&quot;).hasClass(&quot;active&quot;))&#123; addMouseoverHandler(markerInfo[i].id,dangerMarker); addClickHandler(markerInfo[i].id,dangerMarker); &#125; &#125; //addClickHandler(markerInfo[i].id,marker2); &#125;&#125; 潮流线渲染潮流线渲染思路：一个点图层（标注已经用百度地图标好，这里只是确定位置），三个线图层（正常、警告、危险），根据类型判断线应该放在哪个类型的集合中，分别配置不同类型的参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190function loadMapV(pointJson,lineJson)&#123; var node_data = &#123;&#125; var normal_edge_data = [] var warning_edge_data = [] var danger_edge_data = [] for(i in pointJson)&#123; var key = pointJson[i].id node_data[key] = &#123; x: parseFloat(pointJson[i].lng), y: parseFloat(pointJson[i].lat), &#125; &#125; for(j in lineJson)&#123; if(lineJson[j].type==&apos;normal&apos;)&#123; normal_edge_data.push( &#123;&quot;source&quot;: lineJson[j].sourceid, &quot;target&quot;: lineJson[j].targetid&#125; ) &#125;else if(lineJson[j].type==&apos;warning&apos;)&#123; warning_edge_data.push( &#123;&quot;source&quot;: lineJson[j].sourceid, &quot;target&quot;: lineJson[j].targetid&#125; ) &#125;else if(lineJson[j].type==&apos;danger&apos;)&#123; danger_edge_data.push( &#123;&quot;source&quot;: lineJson[j].sourceid, &quot;target&quot;: lineJson[j].targetid&#125; ) &#125; &#125; console.log(node_data) console.log(normal_edge_data) var normal_fbundling = mapv.utilForceEdgeBundling() .nodes(node_data) .edges(normal_edge_data); var normal_results = normal_fbundling(); var warning_fbundling = mapv.utilForceEdgeBundling() .nodes(node_data) .edges(warning_edge_data); var warning_results = warning_fbundling(); var danger_fbundling = mapv.utilForceEdgeBundling() .nodes(node_data) .edges(danger_edge_data); var danger_results = danger_fbundling(); var normal_data = []; var normal_timeData = []; var warning_data = []; var warning_timeData = []; var danger_data = []; var danger_timeData = []; for (var i = 0; i &lt; normal_results.length; i++) &#123; var normal_line = normal_results[i]; var normal_coordinates = []; for (var j = 0; j &lt; normal_line.length; j++) &#123; normal_coordinates.push([normal_line[j].x, normal_line[j].y]); normal_timeData.push(&#123; geometry: &#123; type: &apos;Point&apos;, coordinates: [normal_line[j].x, normal_line[j].y] &#125;, count: 1, time: j &#125;); &#125; normal_data.push(&#123; geometry: &#123; type: &apos;LineString&apos;, coordinates: normal_coordinates &#125; &#125;); &#125; for (var i = 0; i &lt; warning_results.length; i++) &#123; var warning_line = warning_results[i]; var warning_coordinates = []; for (var j = 0; j &lt; warning_line.length; j++) &#123; warning_coordinates.push([warning_line[j].x, warning_line[j].y]); warning_timeData.push(&#123; geometry: &#123; type: &apos;Point&apos;, coordinates: [warning_line[j].x, warning_line[j].y] &#125;, count: 1, time: j &#125;); &#125; warning_data.push(&#123; geometry: &#123; type: &apos;LineString&apos;, coordinates: warning_coordinates &#125; &#125;); &#125; for (var i = 0; i &lt; danger_results.length; i++) &#123; var danger_line = danger_results[i]; var danger_coordinates = []; for (var j = 0; j &lt; danger_line.length; j++) &#123; danger_coordinates.push([danger_line[j].x, danger_line[j].y]); danger_timeData.push(&#123; geometry: &#123; type: &apos;Point&apos;, coordinates: [danger_line[j].x, danger_line[j].y] &#125;, count: 1, time: j &#125;); &#125; danger_data.push(&#123; geometry: &#123; type: &apos;LineString&apos;, coordinates: danger_coordinates &#125; &#125;); &#125; var normal_dataSet = new mapv.DataSet(normal_data); var warning_dataSet = new mapv.DataSet(warning_data); var danger_dataSet = new mapv.DataSet(danger_data); var options = &#123; strokeStyle: &apos;rgba(47, 140, 141, 0.3)&apos;, draw: &apos;simple&apos; &#125; var mapvLayer = new mapv.baiduMapLayer(map, normal_dataSet, options); var mapvLayer = new mapv.baiduMapLayer(map, warning_dataSet, options); var mapvLayer = new mapv.baiduMapLayer(map, danger_dataSet, options); var n_dataSet = new mapv.DataSet(normal_timeData); var w_dataSet = new mapv.DataSet(warning_timeData); var d_dataSet = new mapv.DataSet(danger_timeData); var n_options = &#123; fillStyle: &apos;rgba(255, 250, 250, 0.9)&apos;, globalCompositeOperation: &apos;lighter&apos;, size: 2, animation: &#123; type: &apos;time&apos;, stepsRange: &#123; start: 0, end: 100 &#125;, trails: 2, duration: 5, &#125;, draw: &apos;simple&apos; &#125; var mapvLayer = new mapv.baiduMapLayer(map, n_dataSet, n_options); var w_options = &#123; fillStyle: &apos;rgba(167, 136, 5, 0.9)&apos;, globalCompositeOperation: &apos;lighter&apos;, size: 2, animation: &#123; type: &apos;time&apos;, stepsRange: &#123; start: 0, end: 100 &#125;, trails: 2, duration: 4, &#125;, draw: &apos;simple&apos; &#125; var mapvLayer = new mapv.baiduMapLayer(map, w_dataSet, w_options); var d_options = &#123; fillStyle: &apos;rgba(149, 41, 17, 0.9)&apos;, globalCompositeOperation: &apos;lighter&apos;, size: 3, animation: &#123; type: &apos;time&apos;, stepsRange: &#123; start: 0, end: 100 &#125;, trails: 2, duration: 3, &#125;, draw: &apos;simple&apos; &#125; var mapvLayer = new mapv.baiduMapLayer(map, d_dataSet, d_options);&#125; 小结多次利用百度地图的API进行事件的绑定，实现弹窗和不同级别的操作控制。在站点级别和区域级别的切换中，重新渲染点线，这种方式有待改善。ajax轮询的方式需要改为websocket实时，减少服务器压力。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"百度地图","slug":"百度地图","permalink":"https://wsrdadian.github.io/tags/百度地图/"}]},{"title":"cytoscape.js(一)布局切换动画+两节点间多个关系展示","slug":"cytoscape-js(一)布局切换动画-两节点间多个关系展示","date":"2019-04-19T07:49:59.000Z","updated":"2019-04-19T08:39:06.564Z","comments":true,"path":"2019/04/19/cytoscape-js(一)布局切换动画-两节点间多个关系展示/","link":"","permalink":"https://wsrdadian.github.io/2019/04/19/cytoscape-js(一)布局切换动画-两节点间多个关系展示/","excerpt":"","text":"需求仍然是关系图的展示，前面用到的vis.js在显示两个节点间多个关系时的表现有些鸡肋，同时布局切换时没有动画效果（节点逐渐移动边随之移动），这一周特尝试了sigma.js，它在布局切换时的动画很吸引人，但是同样的问题，不支持两节点多个关系的展示，所以也是从入门到放弃了，下面会分别就 sigma.js 来谈谈问题 两节点间同方向多个关系的展示 布局切换动画效果 问题分析两节点间同方向多个关系的展示 生成曲线边的时候，发现使用的是贝塞尔曲线来画线，除了已知起始点坐标，我们需要知道一个控制点坐标，在 sigma.js 中，算法根据起始点坐标计算出一个控制点，所以只要坐标不变，无论几条边，控制点永远是一个，这样就导致边重合在一起1234567891011121314151617181920212223242526272829sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) &#123; return &#123; x: (x1 + x2) / 2 + (y2 - y1) / 4, y: (y1 + y2) / 2 + (x1 - x2) / 4 &#125;;&#125;;sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) &#123; // http://stackoverflow.com/a/5634528 return &#123; x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2, y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2 &#125;; &#125;;sigma.utils.getPointOnBezierCurve = function(t, x1, y1, x2, y2, cx, cy, dx, dy) &#123; // http://stackoverflow.com/a/15397596 // Blending functions: var B0_t = Math.pow(1 - t, 3), B1_t = 3 * t * Math.pow(1 - t, 2), B2_t = 3 * Math.pow(t, 2) * (1 - t), B3_t = Math.pow(t, 3); return &#123; x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2), y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2) &#125;;&#125;; 布局切换动画 sigma.js 的切换动画真的很吸引人，我是通过 gephi 进行布局，生成节点的坐标，并生成为 json 导出，sigma.js 的动画需要将不同的坐标放在一个 json 中，使用不同的前缀区分。这样我在做的时候需要读每个布局文件然后取出节点坐标，根据id追加到对应的节点对象中，将不同布局的节点坐标存进去。个人认为，如果不需要对关系图进行很强的数据操作，只求显示效果好的话，sigma.js真的是一个不错的选择123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051for (i = 0; i &lt; N; i++) &#123; o = &#123; id: &apos;n&apos; + i, label: &apos;Node &apos; + i, circular_x: L * Math.cos(Math.PI * 2 * i / N - Math.PI / 2), circular_y: L * Math.sin(Math.PI * 2 * i / N - Math.PI / 2), circular_size: Math.random(), circular_color: &apos;#&apos; + ( Math.floor(Math.random() * 16777215).toString(16) + &apos;000000&apos; ).substr(0, 6), grid_x: i % L, grid_y: Math.floor(i / L), grid_size: 1, grid_color: &apos;#ccc&apos; &#125;; [&apos;x&apos;, &apos;y&apos;, &apos;size&apos;, &apos;color&apos;].forEach(function(val) &#123; o[val] = o[&apos;grid_&apos; + val]; &#125;); g.nodes.push(o);&#125;for (i = 0; i &lt; E; i++) g.edges.push(&#123; id: &apos;e&apos; + i, source: &apos;n&apos; + (Math.random() * N | 0), target: &apos;n&apos; + (Math.random() * N | 0) &#125;);// Instantiate sigma:s = new sigma(&#123; graph: g, container: &apos;graph-container&apos;, settings: &#123; animationsTime: 1000 &#125;&#125;);setInterval(function() &#123; var prefix = [&apos;grid_&apos;, &apos;circular_&apos;][step = +!step]; sigma.plugins.animate( s, &#123; x: prefix + &apos;x&apos;, y: prefix + &apos;y&apos;, size: prefix + &apos;size&apos;, color: prefix + &apos;color&apos; &#125; );&#125;, 2000); 全能cytoscape.js 完美支持两节点间多个关系的显示，这点是 vis.js 和 sigma.js 都没有很好的支持，光是这点就让我爱上这个库了！下面贴几行我折腾出来的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var cy = cytoscape(&#123; container: document.getElementById(&apos;cy&apos;), boxSelectionEnabled: false, autounselectify: true, style: cytoscape.stylesheet() .selector(&apos;node&apos;) .style(&#123; &apos;content&apos;: &apos;data(id)&apos; &#125;) .selector(&apos;edge&apos;) .style(&#123; &apos;curve-style&apos;: &apos;bezier&apos;, &apos;target-arrow-shape&apos;: &apos;triangle&apos;, &apos;width&apos;: 4, &apos;line-color&apos;: &apos;#ddd&apos;, &apos;target-arrow-color&apos;: &apos;#ddd&apos; &#125;) .selector(&apos;.highlighted&apos;) .style(&#123; &apos;background-color&apos;: &apos;#61bffc&apos;, &apos;line-color&apos;: &apos;#61bffc&apos;, &apos;target-arrow-color&apos;: &apos;#61bffc&apos;, &apos;transition-property&apos;: &apos;background-color, line-color, target-arrow-color&apos;, &apos;transition-duration&apos;: &apos;0.5s&apos; &#125;), elements: &#123; nodes: [ &#123; data: &#123; id: &apos;a&apos; &#125; &#125;, &#123; data: &#123; id: &apos;b&apos; &#125; &#125;, &#123; data: &#123; id: &apos;c&apos; &#125; &#125;, &#123; data: &#123; id: &apos;d&apos; &#125; &#125;, &#123; data: &#123; id: &apos;e&apos; &#125; &#125; ], edges: [ &#123; data: &#123; id: &apos;ae1&apos;, weight: 1, source: &apos;a&apos;, target: &apos;e&apos; &#125; &#125;, &#123; data: &#123; id: &apos;ab&apos;, weight: 3, source: &apos;a&apos;, target: &apos;b&apos; &#125; &#125;, &#123; data: &#123; id: &apos;be&apos;, weight: 4, source: &apos;b&apos;, target: &apos;e&apos; &#125; &#125;, &#123; data: &#123; id: &apos;bc&apos;, weight: 5, source: &apos;b&apos;, target: &apos;c&apos; &#125; &#125;, &#123; data: &#123; id: &apos;ce&apos;, weight: 6, source: &apos;c&apos;, target: &apos;e&apos; &#125; &#125;, &#123; data: &#123; id: &apos;cd&apos;, weight: 2, source: &apos;c&apos;, target: &apos;d&apos; &#125; &#125;, &#123; data: &#123; id: &apos;de&apos;, weight: 7, source: &apos;d&apos;, target: &apos;e&apos; &#125; &#125;, &#123; data: &#123; id: &apos;ae2&apos;, weight: 1, source: &apos;a&apos;, target: &apos;e&apos; &#125; &#125; ] &#125;, layout: &#123; name: &apos;circle&apos; &#125;&#125;);var id = &#123;&#125;;var data = fetch(&apos;data.json&apos;, &#123;mode: &apos;no-cors&apos;&#125;) .then(function(res) &#123; return res.json() &#125;) .then(function(data) &#123; data.forEach(function(e,i)&#123; cy.elements().nodes().forEach(function( node )&#123; if(e.data.id == node.id())&#123; node.animate(&#123; position: &#123; x: e.position.x, y: e.position.y &#125; &#125;,&#123; duration: 1000 &#125;) &#125; &#125;); &#125;) &#125;); 这是切换布局的动画，读json并获取对应id的坐标，使用动画移动到响应的位置，后面需要生成历史的话，可能我会根据sigma.js的思路来做 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859fetch(&apos;data.json&apos;, &#123;mode: &apos;no-cors&apos;&#125;) .then(function(res) &#123; return res.json() &#125;) .then(function(data) &#123; console.log(data); var toJson = function(res)&#123; return res.json(); &#125;; var cy = window.cy = cytoscape(&#123; container: document.getElementById(&apos;cy&apos;), layout: &#123; name: &apos;circle&apos; &#125;, style: fetch(&apos;cy-style.json&apos;).then(toJson), elements: data &#125;); cy.nodes().animate(&#123; style: &#123; &apos;background-color&apos;: &apos;blue&apos; &#125; &#125;, &#123; duration: 1000 &#125;); &#125;); //以下为cy_style.json [&#123; &quot;selector&quot;: &quot;node&quot;, &quot;style&quot;: &#123; &quot;text-valign&quot;: &quot;center&quot;, &quot;text-halign&quot;: &quot;left&quot;, &quot;width&quot;: 16, &quot;height&quot;: 16, &quot;background-color&quot;: &quot;red&quot; &#125;&#125;, &#123; &quot;selector&quot;: &quot;node[type]&quot;, &quot;style&quot;: &#123; &quot;label&quot;: &quot;data(type)&quot; &#125;&#125;, &#123; &quot;selector&quot;: &quot;edge&quot;, &quot;style&quot;: &#123; &quot;width&quot;: 1, &quot;curve-style&quot;: &quot;bezier&quot; &#125;&#125;, &#123; &quot;selector&quot;: &quot;edge[arrow]&quot;, &quot;style&quot;: &#123; &quot;target-arrow-shape&quot;: &quot;data(arrow)&quot; &#125;&#125;, &#123; &quot;selector&quot;: &quot;edge.hollow&quot;, &quot;style&quot;: &#123; &quot;target-arrow-fill&quot;: &quot;hollow&quot; &#125;&#125;] data.json我就不贴了，按照格式自己写几条测试两节点间多条边的数据即可 总结布局的动画切换这个部分其实还是手动了，如果只需要更改layout对应参数就能使点移动会更加完美，不过手动也好，学习深度会增加，有时间一定要看看如何实现的两节点间多条变不重合，看看贝塞尔的控制点是如何变的。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"关系图","slug":"关系图","permalink":"https://wsrdadian.github.io/tags/关系图/"},{"name":"cytoscape.js","slug":"cytoscape-js","permalink":"https://wsrdadian.github.io/tags/cytoscape-js/"}]},{"title":"vis.js(三)节点操作配置","slug":"vis-js(三)节点操作配置","date":"2019-04-08T07:01:04.000Z","updated":"2019-04-19T07:48:10.001Z","comments":true,"path":"2019/04/08/vis-js(三)节点操作配置/","link":"","permalink":"https://wsrdadian.github.io/2019/04/08/vis-js(三)节点操作配置/","excerpt":"","text":"需求 对canvas中的节点和边数据进行更改，包括增加新节点，修改节点的属性，删除节点的操作，通过对network的配置可以实现 上一篇中构建图标库并拖拽图标产生新节点，由于涉及到dom和canvas的转化，比较麻烦，暂时效果为：点击图标库中的图标，生成一个该实体类型的新节点 代码 html代码（修改节点属性的弹出框） 12345678910111213&lt;div id=&quot;network-popUp&quot;&gt; &lt;span id=&quot;operation&quot;&gt;node&lt;/span&gt; &lt;br&gt; &lt;table style=&quot;margin:auto;&quot;&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt;&lt;td&gt;&lt;input id=&quot;node-id&quot; value=&quot;new value&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;名称&lt;/td&gt;&lt;td&gt;&lt;input id=&quot;node-label&quot; value=&quot;new value&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=&quot;button&quot; value=&quot;save&quot; id=&quot;saveButton&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;cancel&quot; id=&quot;cancelButton&quot; /&gt;&lt;/div&gt; js中对network的配置 123456789101112131415161718192021222324252627282930313233var options = &#123; manipulation: &#123; addNode: function (data, callback) &#123; // filling in the popup DOM elements document.getElementById(&apos;operation&apos;).innerHTML = &quot;Add Node&quot;; document.getElementById(&apos;node-id&apos;).value = data.id; document.getElementById(&apos;node-label&apos;).value = data.label; document.getElementById(&apos;saveButton&apos;).onclick = saveData.bind(this, data, callback); document.getElementById(&apos;cancelButton&apos;).onclick = clearPopUp.bind(); document.getElementById(&apos;network-popUp&apos;).style.display = &apos;block&apos;; &#125;, editNode: function (data, callback) &#123; // filling in the popup DOM elements document.getElementById(&apos;operation&apos;).innerHTML = &quot;Edit Node&quot;; document.getElementById(&apos;node-id&apos;).value = data.id; document.getElementById(&apos;node-label&apos;).value = data.label; document.getElementById(&apos;saveButton&apos;).onclick = saveData.bind(this, data, callback); document.getElementById(&apos;cancelButton&apos;).onclick = cancelEdit.bind(this,callback); document.getElementById(&apos;network-popUp&apos;).style.display = &apos;block&apos;; &#125;, addEdge: function (data, callback) &#123; if (data.from == data.to) &#123; var r = confirm(&quot;Do you want to connect the node to itself?&quot;); if (r == true) &#123; callback(data); &#125; &#125; else &#123; callback(data); &#125; &#125; &#125;&#125; js中新增的函数 12345678910111213141516function saveData(data,callback) &#123; data.id = document.getElementById(&apos;node-id&apos;).value; data.label = document.getElementById(&apos;node-label&apos;).value; clearPopUp(); callback(data);&#125;function clearPopUp() &#123; document.getElementById(&apos;saveButton&apos;).onclick = null; document.getElementById(&apos;cancelButton&apos;).onclick = null; document.getElementById(&apos;network-popUp&apos;).style.display = &apos;none&apos;;&#125;function cancelEdit(callback) &#123; clearPopUp(); callback(null);&#125; 在canvas中出现edit按钮，点击即可对canvas中的节点和边进行修改操作 参考 Network - manipulation network文档 官方示例：vis-master\\examples\\network\\other\\manipulation.html","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"vis.js","slug":"vis-js","permalink":"https://wsrdadian.github.io/tags/vis-js/"},{"name":"关系图","slug":"关系图","permalink":"https://wsrdadian.github.io/tags/关系图/"}]},{"title":"vis.js(二)节点及边的个性化配置","slug":"vis.js(二)节点及边的个性化配置","date":"2019-04-02T02:41:22.000Z","updated":"2019-04-02T03:02:29.635Z","comments":true,"path":"2019/04/02/vis.js(二)节点及边的个性化配置/","link":"","permalink":"https://wsrdadian.github.io/2019/04/02/vis.js(二)节点及边的个性化配置/","excerpt":"","text":"需求设计节点的实体及关系样式，如果在json中设置，会发现出现大量的重复的数据，所以把每个实体类型单独拿出来作为组(group) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var options = &#123; nodes: &#123; shape: &apos;dot&apos;, font: &#123; face: &apos;Tahoma&apos; &#125;, borderWidth:1.5, scaling:&#123; label: &#123; min: 1, max: 5 &#125; &#125;, font: &#123;size:12, color:&apos;#626568&apos;&#125; &#125;, edges: &#123; width: 0.2, smooth: &#123; type: &apos;continuous&apos; &#125;, arrows: &quot;to&quot;, &#125;, groups: &#123; Person: &#123; shape: &quot;circularImage&quot;, image: &quot;./images/Person.png&quot;, color: &#123; background: &quot;#fff&quot;, border: &quot;#022240&quot;, highlight: &#123; &quot;border&quot;: &quot;#d70007&quot;, &quot;background&quot;: &quot;#fec40a&quot; &#125; &#125; &#125;, Woman: &#123; shape: &quot;circularImage&quot;, image: &quot;./images/Woman.png&quot;, color: &#123; background: &quot;#fff&quot;, border: &quot;#022240&quot;, highlight: &#123; &quot;border&quot;: &quot;#d70007&quot;, &quot;background&quot;: &quot;#fec40a&quot; &#125; &#125; &#125;, Insurgent: &#123; shape: &quot;circularImage&quot;, image: &quot;./images/Insurgent.png&quot;, color: &#123; background: &quot;#fff&quot;, border: &quot;#022240&quot;, highlight: &#123; &quot;border&quot;: &quot;#d70007&quot;, &quot;background&quot;: &quot;#fec40a&quot; &#125; &#125; &#125; &#125;, interaction: &#123; &#125;, physics: false &#125;; 下一个任务制作图标库并实现拖拽图标添加新节点并为节点添加label和边","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"vis.js","slug":"vis-js","permalink":"https://wsrdadian.github.io/tags/vis-js/"},{"name":"关系图","slug":"关系图","permalink":"https://wsrdadian.github.io/tags/关系图/"}]},{"title":"vis.js(一)节点及边的操作","slug":"vis.js(一)节点及边的操作","date":"2019-03-30T02:49:01.000Z","updated":"2019-04-02T02:58:21.509Z","comments":true,"path":"2019/03/30/vis.js(一)节点及边的操作/","link":"","permalink":"https://wsrdadian.github.io/2019/03/30/vis.js(一)节点及边的操作/","excerpt":"","text":"介绍用途vis.js 是基于浏览器的动态可视化库。该库旨在易于使用，处理大量动态数据，以及实现对数据的操作和交互。该库由组件DataSet，Timeline，Network，Graph2d和Graph3d组成。我这里做关系图，所以目前主要针对 Network 进行学习。 安装 使用 npm 安装 github 直接 clone 或者 下载包 目录结构我是通过 github 下载包获取代码，不过目录结构应该类似，下面介绍一下 Network 的主要学习的部分。进入 \\vis-master\\examples\\network 目录 data目录datasets.html 渲染一个基本的 network 1234567891011121314151617181920212223242526272829303132function startNetwork() &#123; // this list is kept to remove a random node.. we do not add node 1 here because it&apos;s used for changes nodeIds = [2, 3, 4, 5]; shadowState = false; // create an array with nodes 每个节点有一个唯一的 id ，label 为节点的标签 nodesArray = [ &#123;id: 1, label: &apos;Node 1&apos;&#125;, &#123;id: 2, label: &apos;Node 2&apos;&#125;, &#123;id: 3, label: &apos;Node 3&apos;&#125;, &#123;id: 4, label: &apos;Node 4&apos;&#125;, &#123;id: 5, label: &apos;Node 5&apos;&#125; ]; //使用 DataSet 函数将节点和边转化为 vis 节点和边对象 nodes = new vis.DataSet(nodesArray); // create an array with edges 每条边有入度和出度，调用节点 id edgesArray = [ &#123;from: 1, to: 3&#125;, &#123;from: 1, to: 2&#125;, &#123;from: 2, to: 4&#125;, &#123;from: 2, to: 5&#125; ]; edges = new vis.DataSet(edgesArray); // create a network 渲染 network 需要 Dom 中有一个 id 为 mynetwork 的 div 作为容器 var container = document.getElementById(&apos;mynetwork&apos;); //设置渲染数据和参数，用 Network 函数生成即可。可以通过设置 options 来生成自定义 network var data = &#123; nodes: nodes, edges: edges &#125;; var options = &#123;&#125;; network = new vis.Network(container, data, options);&#125; 添加一个随机生成的节点 1234567function addNode() &#123; //random() 方法可返回介于 0 ~ 1 之间的一个随机数，1e7表示10000000 //Number.toString()：将数字转换为字符串。用它的参数指定的基数或底数（底数范围为2-36）。如果省略参数，则使用基数10。当参数值为2时，返回二进制数。，并返回结果 var newId = (Math.random() * 1e7).toString(32); nodes.add(&#123;id:newId, label:&quot;I&apos;m new!&quot;&#125;); nodeIds.push(newId);&#125; 参考博客： 一些有用的JS 代码片段 改变指定节点的属性并更新 123456function changeNode1() &#123; //Math.floor()返回小于或等于一个给定数字的最大整数 var newColor = &apos;#&apos; + Math.floor((Math.random() * 255 * 255 * 255)).toString(16); //更新指定id的节点属性，传入 id 和更改的节点属性 nodes.update([&#123;id:1, color:&#123;background:newColor&#125;&#125;]);&#125; 移除指定节点 123456789function removeRandomNode() &#123; var randomNodeId = nodeIds[Math.floor(Math.random() * nodeIds.length)]; //移除指定id节点 nodes.remove(&#123;id:randomNodeId&#125;); //indexOf() 方法可返回某个指定的字符串值在字符串和数组中首次出现的位置。 var index = nodeIds.indexOf(randomNodeId); //splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。index规定添加/删除项目的位置，1是要删除的项目数量 nodeIds.splice(index,1);&#125; 移除节点分两步，先移除指定id节点，然后在节点id数组中移除该id值 修改全局节点属性 1234function changeOptions() &#123; shadowState = !shadowState; network.setOptions(&#123;nodes:&#123;shadow:shadowState&#125;,edges:&#123;shadow:shadowState&#125;&#125;);&#125; 重新加载为初始状态 123456function resetAllNodes() &#123; nodes.clear(); edges.clear(); nodes.add(nodesArray); edges.add(edgesArray);&#125; 重新加载为稳定的初始状态 1234function resetAllNodesStabilize() &#123; resetAllNodes(); network.stabilize();&#125; 设为稳定状态 12345function setTheData() &#123; nodes = new vis.DataSet(nodesArray); edges = new vis.DataSet(edgesArray); network.setData(&#123;nodes:nodes, edges:edges&#125;)&#125; 销毁dom并重新渲染 1234567function resetAll() &#123; if (network !== null) &#123; network.destroy(); network = null; &#125; startNetwork();&#125; dynamicData.html 添加节点 1234567891011function addNode() &#123; try &#123; nodes.add(&#123; id: document.getElementById(&apos;node-id&apos;).value, label: document.getElementById(&apos;node-label&apos;).value &#125;); &#125; catch (err) &#123; alert(err); &#125;&#125; 更新:保存修改后的节点信息（如果不存在id则添加，已存在id则修改） 1234567891011function updateNode() &#123; try &#123; nodes.update(&#123; id: document.getElementById(&apos;node-id&apos;).value, label: document.getElementById(&apos;node-label&apos;).value &#125;); &#125; catch (err) &#123; alert(err); &#125;&#125; 添加和更新边和节点类似 移除 12345678function removeNode() &#123; try &#123; nodes.remove(&#123;id: document.getElementById(&apos;node-id&apos;).value&#125;); &#125; catch (err) &#123; alert(err); &#125;&#125; 渲染 12345678910111213141516171819202122232425262728293031323334353637function draw() &#123; // create an array with nodes nodes = new vis.DataSet(); nodes.on(&apos;*&apos;, function () &#123; //JSON.stringify() 方法将 JavaScript 对象转换为字符串 document.getElementById(&apos;nodes&apos;).innerHTML = JSON.stringify(nodes.get(), null, 4); &#125;); nodes.add([ &#123;id: &apos;1&apos;, label: &apos;Node 1&apos;&#125;, &#123;id: &apos;2&apos;, label: &apos;Node 2&apos;&#125;, &#123;id: &apos;3&apos;, label: &apos;Node 3&apos;&#125;, &#123;id: &apos;4&apos;, label: &apos;Node 4&apos;&#125;, &#123;id: &apos;5&apos;, label: &apos;Node 5&apos;&#125; ]); // create an array with edges edges = new vis.DataSet(); edges.on(&apos;*&apos;, function () &#123; document.getElementById(&apos;edges&apos;).innerHTML = JSON.stringify(edges.get(), null, 4); &#125;); edges.add([ &#123;id: &apos;1&apos;, from: &apos;1&apos;, to: &apos;2&apos;&#125;, &#123;id: &apos;2&apos;, from: &apos;1&apos;, to: &apos;3&apos;&#125;, &#123;id: &apos;3&apos;, from: &apos;2&apos;, to: &apos;4&apos;&#125;, &#123;id: &apos;4&apos;, from: &apos;2&apos;, to: &apos;5&apos;&#125; ]); // create a network var container = document.getElementById(&apos;network&apos;); var data = &#123; nodes: nodes, edges: edges &#125;; var options = &#123;&#125;; network = new vis.Network(container, data, options);&#125; 参考JSON.stringify()","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"vis.js","slug":"vis-js","permalink":"https://wsrdadian.github.io/tags/vis-js/"},{"name":"关系图","slug":"关系图","permalink":"https://wsrdadian.github.io/tags/关系图/"}]},{"title":"json接口的问题以及解决方法","slug":"json接口的问题以及解决方法","date":"2019-03-22T05:49:14.000Z","updated":"2019-03-25T05:53:41.575Z","comments":true,"path":"2019/03/22/json接口的问题以及解决方法/","link":"","permalink":"https://wsrdadian.github.io/2019/03/22/json接口的问题以及解决方法/","excerpt":"","text":"问题接上一篇《定义json数据接口》，根据新的需求，现有的代码已经不能满足，所以要把部分代码推倒重写，依然是json的问题：在上一篇中，url获取之后，先进行 &amp; 切割，再进行 = 切割,由于对 = 进行切割，所以当我们想往信息窗口的 info 中添加 html 时，如果其中带有 = ，会导致被切割，字符串被打断。由此提出两个解决办法： 指定切割第一次出现的 = 定义正则匹配函数 参数中有 html 携带的 . 和 / 等特殊符号导致字符串转对象时报错 解决 获取 url 参数，这里将 url 和想获取的数据名 key 传入到正则匹配函数 getQueryString 中： 1234function getUrl()&#123; var url = decodeURI(window.location.search.substring(1)); getQueryString(url,&apos;data&apos;);&#125; 正则匹配传入的名字和url，根据名字从 url 中匹配 val 值，如果匹配成功，则将字符串转为 json 对象，对格式进行判断，如果正确则进行参数匹配。 12345678910111213141516function getQueryString(url,name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); //开始位置或者&amp;符+名+[个数不限]+&amp;符或者结束位置 console.log(reg); var r = url.match(reg); if (r != null) &#123; try&#123; data = $.parseJSON(r[2]); matchQuery(data); &#125;catch(err)&#123; alert(&quot;参数格式有误！&quot;); return; &#125; &#125; return null; &#125; 得到 json 对象后，对其进行遍历，逐层遍历出想要的点对象，将对象传入封装好的函数中即可。 1234567891011121314151617function matchQuery(data)&#123; $.each(data, function (key, val) &#123; $.each(data[key], function (k, v) &#123; if(k == &apos;markerInfo&apos;)&#123; addMarkerInfo(v); &#125; if(k == &apos;heatPoints&apos;)&#123; addHeat(v); &#125; if(k == &apos;linePoints&apos;)&#123; addLine(v); addMarkerInfo(v); &#125; &#125;); &#125;);&#125; 解决 html 报错：将 data = $.parseJSON(data); 改为 eval(“(“+data+”)”) 1var dataObj=eval(&quot;(&quot;+data+&quot;)&quot;);//转换为json对象 参考博客jQuery中json中关于带有html代码网页的处理 小总结使用正则匹配很方便，虽然看起来像乱码，但是还是很实用的，需要学习。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"百度地图","slug":"百度地图","permalink":"https://wsrdadian.github.io/tags/百度地图/"}]},{"title":"定义json数据接口","slug":"定义json数据接口","date":"2019-03-21T07:38:07.000Z","updated":"2019-03-21T08:49:20.898Z","comments":true,"path":"2019/03/21/定义json数据接口/","link":"","permalink":"https://wsrdadian.github.io/2019/03/21/定义json数据接口/","excerpt":"","text":"需求 绘制两点间带箭头的线段，起点终点使用标注标记并点击标注弹出信息窗口。 绘制热力图，根据点坐标及权重（权重越大，点显示越显著）。 添加点击出现弹出框的标注点。 数据 根据函数需要，设计需要传入的参数数据，用json格式写出。 1url?markerInfo=[&#123;&quot;lng&quot;:&quot;116.417854&quot;,&quot;lat&quot;:&quot;39.921988&quot;,&quot;info&quot;:&quot;地址：北京市东城区王府井大街88号乐天银泰百货八层&quot;&#125;,&#123;&quot;lng&quot;:&quot;116.406605&quot;,&quot;lat&quot;:&quot;39.921585&quot;,&quot;info&quot;:&quot;地址：北京市东城区东华门大街&quot;&#125;,&#123;&quot;lng&quot;:&quot;116.412222&quot;,&quot;lat&quot;:&quot;39.912345&quot;,&quot;info&quot;:&quot;地址：北京市东城区正义路甲5号&lt;a href:&apos;../baidu.com&apos;&gt;&lt;/a&gt;&quot;&#125;]&amp;linePoints=[&#123;&quot;lng&quot;:&quot;116.399&quot;,&quot;lat&quot;:&quot;39.930&quot;&#125;,&#123;&quot;lng&quot;:&quot;116.505&quot;,&quot;lat&quot;:&quot;39.950&quot;&#125;]&amp;heatPoints=[&#123;&quot;lng&quot;:&quot;116.405&quot;,&quot;lat&quot;:&quot;39.910&quot;,&quot;count&quot;:&quot;50&quot;&#125;,&#123;&quot;lng&quot;:&quot;116.399&quot;,&quot;lat&quot;:&quot;39.920&quot;,&quot;count&quot;:&quot;51&quot;&#125;] 便于查看，json格式化之后如下（中间脑补 &amp; 符）： 123456789101112131415161718192021222324252627282930313233343536373839markerInfo=[ &#123; &quot;lng&quot;: &quot;116.417854&quot;, &quot;lat&quot;: &quot;39.921988&quot;, &quot;info&quot;: &quot;地址：北京市东城区王府井大街88号乐天银泰百货八层&quot; &#125;, &#123; &quot;lng&quot;: &quot;116.406605&quot;, &quot;lat&quot;: &quot;39.921585&quot;, &quot;info&quot;: &quot;地址：北京市东城区东华门大街&quot; &#125;, &#123; &quot;lng&quot;: &quot;116.412222&quot;, &quot;lat&quot;: &quot;39.912345&quot;, &quot;info&quot;: &quot;地址：北京市东城区正义路甲5号&lt;a href:&apos;../baidu.com&apos;&gt;&lt;/a&gt;&quot; &#125;]linePoints=[ &#123; &quot;lng&quot;: &quot;116.399&quot;, &quot;lat&quot;: &quot;39.930&quot; &#125;, &#123; &quot;lng&quot;: &quot;116.505&quot;, &quot;lat&quot;: &quot;39.950&quot; &#125;]heatPoints=[ &#123; &quot;lng&quot;: &quot;116.405&quot;, &quot;lat&quot;: &quot;39.910&quot;, &quot;count&quot;: &quot;50&quot; &#125;, &#123; &quot;lng&quot;: &quot;116.399&quot;, &quot;lat&quot;: &quot;39.920&quot;, &quot;count&quot;: &quot;51&quot; &#125;] 绘制 获取参数，进行字转义，然后根据 &amp; 进行切割，取到对应的 k=v 对象，然后进行遍历，如果存在相应的 k ，则检查 v 是否符合 json 格式，如果不符合 json 格式，弹出提示框；如果符合，调用对应的创建函数。要保证代码的健壮性，这里对url的格式错误进行提示，同时避免其他参数传入影响接收，在切割字符串时应避免设置固定的数值。 1234567891011121314151617181920212223242526272829303132333435363738394041function getQueryVariable()&#123; var query = decodeURI(window.location.search.substring(1)); console.log(query); if (query.indexOf(&quot;?&quot;)) &#123; query = query.replace(/%22/g,&apos;&quot;&apos;).replace(/%27/g,&apos;&quot;&apos;).replace(/%20/g,&apos; &apos;); //.replace(/%5C/g,&apos;\\\\&apos;).replace(/%3A/g,&apos;:&apos;).replace(/%3B/g,&apos;;&apos;); strs = query.split(&quot;&amp;&quot;); for(var i = 0; i &lt; strs.length; i ++) &#123; var key = strs[i].split(&quot;=&quot;)[0]; var val = unescape(strs[i].split(&quot;=&quot;)[1]); if(key == &apos;heatPoints&apos;) &#123; try&#123; heatPoints = $.parseJSON(val); &#125;catch(err)&#123; alert(&apos;heatPoints参数格式不正确&apos;); break; &#125; addHeat(heatPoints); &#125; if(key == &apos;markerInfo&apos;) &#123; try&#123; markerInfo = $.parseJSON(val); &#125;catch(err)&#123; alert(&apos;markerInfo参数格式不正确&apos;); break; &#125; addMarkerInfo(markerInfo); &#125; if(key == &apos;linePoints&apos;) &#123; try&#123; linePoints = $.parseJSON(val); &#125;catch(err)&#123; alert(&apos;linePoints参数格式不正确&apos;); break; &#125; addLine(linePoints); addMarkerInfo(linePoints); &#125; &#125; &#125;&#125; 绘制两点间的线段，仅需要起点和终点的经纬度即可，创建一条折线，并绘制箭头。 123456function addLine(linePoints)&#123; var points = []; var lineList = new Array();//记录要绘制的线 var arrowLineList = new Array();//记录绘制的箭头线 var isFirstLoad = false;//是否是第一次加载，第一次加载不触发清除事件 var arrowLineLengthRate = 12 / 1;//15是初始时设置的地图显示范围，10是初始时设置的箭头的长度，当地图放大缩小时保证箭头线长度一致 遍历获取经纬度，并创建为一个坐标点 123456for( i = 0; i &lt; linePoints.length; i++ )&#123; var point = linePoints[i]; var lng = point.lng; var lat = point.lat; points[i] = new BMap.Point(lng, lat);&#125; 对折线进行样式设置，设置完成之后，传入点数组，创建折线 123456789101112 var polyline = new BMap.Polyline( points , &#123; strokeWeight:&apos;3&apos;,//折线的宽度，以像素为单位 strokeOpacity: 0.5,//折线的透明度，取值范围0 - 1 strokeColor:&quot;blue&quot; //折线颜色 &#125;); //创建折线 map.addOverlay(polyline); //增加折线 lineList[lineList.length] = polyline;//记录要绘制的线 arrowLineList[arrowLineList.length] = addArrow(polyline,15,Math.PI/7);//记录绘制的箭头线 isFitstLoad = true;//第一次加载&#125; 绘制箭头，箭头的算法有些复杂，自行消化。参考博客：百度地图API绘制带头箭头的折线 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function addArrow(polyline,length,angleValue)&#123; //绘制箭头的函数 var linePoint=polyline.getPath();//线的坐标串 var arrowCount=linePoint.length; for(var i =1;i&lt;arrowCount;i++)&#123; //在拐点处绘制箭头 var pixelStart=map.pointToPixel(linePoint[i-1]); var pixelEnd=map.pointToPixel(linePoint[i]); var angle=angleValue;//箭头和主线的夹角 var r=length; // r/Math.sin(angle)代表箭头长度 var delta=0; //主线斜率，垂直时无斜率 var param=0; //代码简洁考虑 var pixelTemX,pixelTemY;//临时点坐标 var pixelX,pixelY,pixelX1,pixelY1;//箭头两个点 if(pixelEnd.x-pixelStart.x==0)&#123; //斜率不存在是时 pixelTemX=pixelEnd.x; if(pixelEnd.y&gt;pixelStart.y) &#123; pixelTemY=pixelEnd.y-r; &#125; else &#123; pixelTemY=pixelEnd.y+r; &#125; //已知直角三角形两个点坐标及其中一个角，求另外一个点坐标算法 pixelX=pixelTemX-r*Math.tan(angle); pixelX1=pixelTemX+r*Math.tan(angle); pixelY=pixelY1=pixelTemY; &#125; else //斜率存在时 &#123; delta=(pixelEnd.y-pixelStart.y)/(pixelEnd.x-pixelStart.x); param=Math.sqrt(delta*delta+1); if((pixelEnd.x-pixelStart.x)&lt;0) //第二、三象限 &#123; pixelTemX=pixelEnd.x+ r/param; pixelTemY=pixelEnd.y+delta*r/param; &#125; else//第一、四象限 &#123; pixelTemX=pixelEnd.x- r/param; pixelTemY=pixelEnd.y-delta*r/param; &#125; //已知直角三角形两个点坐标及其中一个角，求另外一个点坐标算法 pixelX=pixelTemX+ Math.tan(angle)*r*delta/param; pixelY=pixelTemY-Math.tan(angle)*r/param; pixelX1=pixelTemX- Math.tan(angle)*r*delta/param; pixelY1=pixelTemY+Math.tan(angle)*r/param; &#125; var pointArrow=map.pixelToPoint(new BMap.Pixel(pixelX,pixelY)); var pointArrow1=map.pixelToPoint(new BMap.Pixel(pixelX1,pixelY1)); var Arrow = new BMap.Polyline([ pointArrow, linePoint[i], pointArrow1 ], &#123;strokeColor:&quot;blue&quot;, strokeWeight:5, strokeOpacity:0.5&#125;); map.addOverlay(Arrow); return Arrow; &#125; &#125; 以上为带箭头的折线绘制，这时候可能有人会问， 始末点标注怎么没有创建？其实我一开始是在获取经纬度之后直接创建标注了，但是毕竟后面有创建带信息窗口的标注的需求，何不封装一个创建标注函数，哪里需要就直接调用呢？所以我是把创建标注和窗口这部分单独拿出来了。 创建标注点，点击时弹出信息窗口12345678910111213function addMarkerInfo(markerInfo)&#123; for(i=0;i&lt;markerInfo.length;i++)&#123; var marker = new BMap.Marker(new BMap.Point(markerInfo[i].lng,markerInfo[i].lat)); // 创建标注 map.addOverlay(marker); // 将标注添加到地图中 if(markerInfo[i].info)&#123; info = markerInfo[i].info.replace(/:/g,&quot;=&quot;) addClickHandler(info,marker); console.log(info); &#125;else&#123; markerInfo[i].info = &quot;未添加信息&quot;; addClickHandler(markerInfo[i].info,marker); &#125; &#125; 为标注绑定 click 点击事件 123456function addClickHandler(content,marker)&#123; marker.addEventListener(&quot;onclick&quot;,function(e)&#123; openInfo(content,e)&#125; );&#125; 对窗口进行设置 enableAutoPan 是否支持拖拽后自动移回；enableMessage 是否支持手机短信 1234567var opts = &#123; width : 250, // 信息窗口宽度 height: 80, // 信息窗口高度 title : &quot;信息窗口&quot; , // 信息窗口标题 enableAutoPan: false, enableMessage: false,&#125;; 打开信息窗口，获取被点击的标注经纬度，在该位置创建窗口 1234567 function openInfo(content,e)&#123; var p = e.target; var point = new BMap.Point(p.getPosition().lng, p.getPosition().lat); var infoWindow = new BMap.InfoWindow(content,opts); // 创建信息窗口对象 map.openInfoWindow(infoWindow,point); //开启信息窗口 &#125;&#125; 创建热力图1234567891011121314151617function addHeat(heatPoints)&#123; var heatmapOverlay = new BMapLib.HeatmapOverlay(&#123; &quot;radius&quot;:10, &quot;visible&quot;:true, &quot;opacity&quot;:70 , &quot;gradient&quot;:&#123; 0:&apos;rgba(255, 255, 255, 0.5)&apos;, 0.25:&apos;rgb(0,0,255)&apos;, .5:&apos;rgb(0, 255, 0)&apos;, 0.75:&apos;rgb(255,255,0)&apos;, 1:&apos;rgb(255, 0, 0)&apos; &#125; &#125;); map.addOverlay(heatmapOverlay); var heatPoints = heatPoints; heatmapOverlay.setDataSet(&#123;data:heatPoints,max:100&#125;);&#125; 热力图的点直接传入json字符串即可自动识别，无需获取经纬度后手动创建点，所以热力图这部分代码量较少。 一些小优化 map必须设置高度，否则不显示，所以不能使用流体布局，但是高度又希望自适应，所以最后的想法是获取窗口高度然后赋值给height12height = $(window).height();$(&quot;#map_container&quot;).css(&quot;height&quot;,height); 注意要在map初始化之前完成。 之前使用 window.onload() ,发现绘制图形简直不是一点点的慢，像页面卡住了一样。原来 window.onload() 是页面全部加载完成之后执行，包括图片文件等，这样看来慢是正常的了，所以果断换成DOM加载完成后执行，改为如下： 123$(document).ready(function()&#123; getQueryVariable();&#125;); 去掉图片水印，当然不是需要PS的那种，是在地图图层上的 div 。这个问题困扰我2天了，之前是想用 remove() 去掉，但是必须先渲染出来才能 remove ，所以效果就是先出现一下，然后瞬间被 remove ，但是还是有一瞬间能看见水印，不符合需求。最后实现的想法是，直接给这个 div 加一个 display:none 的 css。之前一直在纠结想从根源上去除，转变一下思路瞬间就解决了，而且还很简单。下次还是要多考虑几个方案。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"百度地图","slug":"百度地图","permalink":"https://wsrdadian.github.io/tags/百度地图/"}]},{"title":"百度地图瓦片相关问题","slug":"百度地图瓦片相关问题","date":"2019-03-15T06:52:02.000Z","updated":"2019-03-15T08:02:51.088Z","comments":true,"path":"2019/03/15/百度地图瓦片相关问题/","link":"","permalink":"https://wsrdadian.github.io/2019/03/15/百度地图瓦片相关问题/","excerpt":"","text":"百度地图的瓦片下载真的是一个巨大的工程量，我下载到15级，瓦片文件已经达到17G，其实还可以更精确一点，但是感觉电脑快跑报废了，而且目前项目要求到15级即可。 瓦片下载工具使用 瓦片下载器不是收费就是有层级限制，在前面的文章 《使用Python离线地图》中，已经使用了一个开源的python工具来下载，但是由于下载下来的瓦片组织性不强，迁移费力，以及merge时出现的内存不够，电脑卡死等问题，不得不重新寻找下载瓦片并保证离线地图能正常使用的方法，经过一个周末终于找到了一个免费的下载器： BaiduMapTile。 进入 BaiduMapTile\\BaiduMapTile\\bin\\Debug\\BaiduMapTile.exe 填写经纬度，瓦片自动下载到 \\BaiduMapTile\\BaiduMapTile\\bin\\Debug\\html\\maptile 目录下，并按照经纬度自动创建文件目录，这次的方式，无需合成瓦片，在显示时，会按照经纬度自动寻找相应的文件目录，显示瓦片。 离线地图使用 瓦片下载完成后，将瓦片文件复制到 BaiduMapTile\\html\\maptile 文件夹中，并按照 map.txt 对apiv2.0_street.js 进行修改，为了避免控制台报错，在 1494 行将 appendChild 去掉，避免生成调用在线API的 head 文件1document.getElementsByTagName(&quot;head&quot;)[0];//.appendChild(d) 百度地图API调用画折线 在百度API文档中下载 CurveLine.js 文件，并引入 1&lt;script type=&quot;text/javascript&quot; src=&quot;js/CurveLine.js&quot;&gt;&lt;/script&gt; 渲染地图，并画一条简单的折线 12345678910111213var map = new BMap.Map(&quot;container&quot;,&#123;mapType: BMAP_NORMAL_MAP&#125;); var point = new BMap.Point(116.404, 39.915); // 创建点坐标 map.centerAndZoom(point,15); // 初始化地图,设置中心点坐标和地图级别。 //map.addControl(new BMap.MapTypeControl()); map.addControl(new BMap.NavigationControl()); map.enableScrollWheelZoom(); // 启用滚轮放大缩小。 map.enableKeyboard(); // 启用键盘操作。 var polyline = new BMap.Polyline([ new BMap.Point(116.399, 39.910), new BMap.Point(116.405, 39.920), new BMap.Point(116.423493, 39.907445) ], &#123;strokeColor:&quot;blue&quot;, strokeWeight:2, strokeOpacity:0.5&#125;); //创建折线map.addOverlay(polyline); //增加折线 热力图 在百度API文档中下载 CurveLine.js 文件，并引入Heatmap.js 1&lt;script type=&quot;text/javascript&quot; src=&quot;js/Heatmap.min.js&quot;&gt;&lt;/script&gt; 创建一些热力点，一般放在JSON文件中调用,例如： 123456var points =[&#123;&quot;lng&quot;:116.418261,&quot;lat&quot;:39.921984,&quot;count&quot;:50&#125;,&#123;&quot;lng&quot;:116.423332,&quot;lat&quot;:39.916532,&quot;count&quot;:51&#125;,&#123;&quot;lng&quot;:116.419787,&quot;lat&quot;:39.930658,&quot;count&quot;:15&#125;,&#123;&quot;lng&quot;:116.418455,&quot;lat&quot;:39.920921,&quot;count&quot;:40&#125;]; 渲染热力图 12345678910111213var heatmapOverlay = new BMapLib.HeatmapOverlay(&#123;&quot;radius&quot;:10, &quot;visible&quot;:true, &quot;opacity&quot;:70 , &quot;gradient&quot;:&#123; 0:&apos;rgba(255, 255, 255, 0.5)&apos;, 0.25:&apos;rgb(0,0,255)&apos;, .5:&apos;rgb(0, 255, 0)&apos;, 0.75:&apos;rgb(255,255,0)&apos;, 1:&apos;rgb(255, 0, 0)&apos;&#125;&#125;);map.addOverlay(heatmapOverlay);heatmapOverlay.setDataSet(&#123;data:points,max:100&#125;); gradient 为热力图点的渐变颜色，radius 每个点的半径，visible 是否展示热力图，opacity 热力的透明度 下一步任务将离线出来的地图封装成一个小工具，数据全部采用Json格式接口调用。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"百度地图","slug":"百度地图","permalink":"https://wsrdadian.github.io/tags/百度地图/"}]},{"title":"React基础学习（一）","slug":"React基础学习（一）","date":"2019-03-13T03:20:57.000Z","updated":"2019-03-15T08:03:36.496Z","comments":true,"path":"2019/03/13/React基础学习（一）/","link":"","permalink":"https://wsrdadian.github.io/2019/03/13/React基础学习（一）/","excerpt":"","text":"在安装 React 之前需要安装 Node 环境和 NPM 环境 安装并运行 安装 1234$ npm install -g create-react-appC:\\Users\\Administrator\\AppData\\Roaming\\npm\\create-react-app -&gt; C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\create-react-app\\index.js+ create-react-app@2.1.8added 63 packages from 20 contributors in 15.223s 创建一个项目 123456789101112131415161718192021222324252627282930313233343536373839$ create-react-app my-new-appCreating a new React app in F:\\web\\react\\my-new-app.Installing packages. This might take a couple of minutes.Installing react, react-dom, and react-scripts...+ react-dom@16.8.4+ react-scripts@2.1.8+ react@16.8.4added 1839 packages from 718 contributors and audited 36232 packages in 301.026sfound 63 low severity vulnerabilities run `npm audit fix` to fix them, or `npm audit` for detailsInitialized a git repository.Success! Created my-new-app at F:\\web\\react\\my-new-appInside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm test Starts the test runner. npm run eject Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back!We suggest that you begin by typing: cd my-new-app npm startHappy hacking! 运行 12345678910111213141516171819$ cd my-new-app/Administrator@KHMD9Q7MXH8OBVI MINGW64 /f/web/react/my-new-app (master)$ npm start&gt; my-new-app@0.1.0 start F:\\web\\react\\my-new-app&gt; react-scripts startStarting the development server...Compiled successfully!You can now view my-new-app in the browser. Local: http://localhost:3000/ On Your Network: http://192.168.1.101:3000/Note that the development build is not optimized.To create a production build, use npm run build. 下一步任务React脚手架安装完成，接下来是完成一个ToDoList练习。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"React","slug":"React","permalink":"https://wsrdadian.github.io/tags/React/"}]},{"title":"Metronic学习之路(二)","slug":"Metronic学习之路-二","date":"2019-03-13T01:28:16.000Z","updated":"2019-03-13T03:18:48.585Z","comments":true,"path":"2019/03/13/Metronic学习之路-二/","link":"","permalink":"https://wsrdadian.github.io/2019/03/13/Metronic学习之路-二/","excerpt":"","text":"进行框架搭建基础搭建，进行模块化，保持每个页面局部集中；排除不需要的文件和插件。 思路 假定你在 7 个可用的子主题中选择了 Admin 1(admin_1) 子主题。 这个主题有两个部分. 首先是包含了所有 css、js和第三方插件的 assets 文件夹，接着是包含实际 HTML 模板的模板文件夹。可以参考启动时调用的 theme/assets 和 theme/admin_1。 theme/assets 的 layout 文件夹里你可以发现有 7 个独立的 layout 文件夹（如 layout，layou2, … layout7）,你可以保留你用到的 theme/assets/layouts/layout 和 theme/layouts/global 然后将你用不到的 layout 文件夹删除。 这样在theme/assets/layouts 文件夹里你就只有 theme/assets/layouts/layout 和 theme/assets/layouts/global 两个文件夹了。 theme/admin_1 文件夹在 layout_blank_page.html 打开时被引用。这个模板包括了压缩后的 css、js 和第三方插件。你可以用此模板作为你应用程序的起点。试着将 layout_blank_page.html 的代码分离成模块化(header, sidebar, footer, main content)，并保持每个页面局部集中。 在第三方插件文件夹(theme/assets/global/plugins)，你可以排除你用不到的插件. 默认 Metronic 包括 80 个第三方插件， 大部分主题你不会用到，你可以将他们排除。 参考:Metronic学习之路 模块化参考文章：传统HTML页面实现模块化加载 网站需要模块化的原因 Web前端主流模块化框架的区别","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"Metronic","slug":"Metronic","permalink":"https://wsrdadian.github.io/tags/Metronic/"}]},{"title":"Metronic学习之路(一)","slug":"Metronic学习之路-一","date":"2019-03-12T01:42:47.000Z","updated":"2019-03-12T09:25:21.851Z","comments":true,"path":"2019/03/12/Metronic学习之路-一/","link":"","permalink":"https://wsrdadian.github.io/2019/03/12/Metronic学习之路-一/","excerpt":"","text":"使用GULP构建工具对Metronic进行管理 部署gulp 打开终端并进入到 Metronic 的 theme 根目录，运行以下代码1$ npm install //安装程序的依赖包 发现 npm install 报 node-sass 错误原因: npm install 的时候所下载的 node-sass 文件夹是空的在 C:\\Users\\admin\\AppData\\Roaming\\npm-cache\\node-sass\\3.13.1 下面可以看到解决方法:自己单独用 npm i node-sass 下载一遍会在 C:\\Users\\姓名AppData\\Roaming\\npm-cache\\node-sass\\4.7.2 下面会有一个文件win32-x64-57_binding.node ,把这个文件复制到 3.13.1 下面然后重新 npm install 就解决了 全局安装gulp 1$ npm install gulp -g 测试 gulp，在终端输入 gulp 报错 Cannot find module ‘gulp-prettify’ 模块找不到进入 npm 搜索包名并安装 1$ npm i gulp-prettify 再次执行 gulp 命令 1$ gulp 出现 1234$ gulp[09:53:07] Using gulpfile F:\\web\\metronic_v4.5.2\\theme\\gulpfile.js[09:53:07] Task never defined: default[09:53:07] To list available tasks, try running: gulp --tasks 说明 gulp 部署成功，只是默认任务还没有配置,需要看看 gulpfile.js 列出的其他任务。 如果有其他问题，请参考初探前端自动化神器（Gulp）Bootstrap 之 Metronic 模板的学习之路 - （7）GULP 前端自动化工具 gulp 任务运用gulp localhost 安装 Connect 插件 1npm install--save-dev gulp-connect npm install –save-dev 可以简化为 npm i -D 为 web 服务器定义一个任务， gulpfile.js 文件中添加 123gulp.task(&apos;localhost&apos;, function() &#123; connect.server();&#125;); 只要在终端/命令行中执行 gulp, 就可以启动 web 服务器，然后可以在浏览器中打开 localhost:8080 gulp localhost-live 给 connect.server() 方法传入一个参数12345gulp.task(&apos;localhost-live&apos;, function() &#123; connect.server(&#123; livereload: true &#125;);&#125;); SASS 编译gulp sass打开终端进入到 gulpfile.js 所在的 theme 目录。输入 gulp sass 命令执行手工构建任务。 发现报错 1It&apos;s not clear which file to import for &apos;@import &quot;file&quot;&apos;. 由于 sass _filename.scss 不允许出现 同名无下划线 filename.scss ,写文件全称试试 解决：components-md.scss 中1@import &apos;_components.scss&apos;; 继续执行 gulp sass,发现报错12345Message: sass\\global\\_components.scssError: Import directives may not be used within control directives or mixins. on line 7 of sass/global/_components.scss from line 8 of sass/global/components-md.scss 解决：_components.scss 中 1234// General CSS Reset@if $theme-style == &quot;square&quot; &#123; @import &apos;components/_reset-rounds&apos;;&#125; 去掉 @if 判断 继续执行 gulp sass ,出现新的报错123Error: Undefined variable: &quot;$general-border-radius&quot;. on line 134 of sass/apps/inbox.scss border-radius: $general-border-radius; 解决：global/_variables.scss 中 12345@if $theme-type == &quot;material-design&quot; &#123;$general-border-radius: 2px !default;&#125; @else &#123;$general-border-radius: 4px !default;&#125; 在 @if 前添加 1$general-border-radius: 2px !default; 继续执行 gulp sass ,出现新的报错12The following tasks did not complete: testGulp Did you forget to signal async completion? 官方方法在不使用文件流的情况下，向task的函数里传入一个名叫done的回调函数，以结束task。参考1234gulp.task(&apos;testGulp&apos;, done =&gt; &#123; console.log(&apos;Hello World!&apos;); done();&#125;); gulp sass:watch 输入 gulp sass:watch 运行 scss 实时监控 css 文件的编译，编译后的 css 文件会输出到 assets 目录。12345678Error: watching ./sass/**/*.scss: watch task has to be a function (optionally generated by using gulp.parallel or gulp.series) at Gulp.watch (F:\\web\\metronic_v4.5.2\\theme\\node_modules\\gulp\\index.js:28:11) at F:\\web\\metronic_v4.5.2\\theme\\gulpfile.js:59:10 at taskWrapper (F:\\web\\metronic_v4.5.2\\theme\\node_modules\\undertaker\\lib\\set-task.js:13:15) at bound (domain.js:395:14) at runBound (domain.js:408:12) at asyncRunner (F:\\web\\metronic_v4.5.2\\theme\\node_modules\\async-done\\index.js:55:18) at process._tickCallback (internal/process/next_tick.js:61:11) 分析：这个是由于require引入的包的版本问题导致的。在不同的版本里，接口参数发生了变化。在gulp4.0之后已经只能接受watch第二个参数必须为函数。解决办法：修改gulpfile.js123gulp.task(&apos;sass:watch&apos;, function () &#123; gulp.watch(&apos;./sass/**/*.scss&apos;,gulp.series(&apos;sass&apos;));&#125;); RTL SASS 编译 因为 RTL 的主题文件和默认的主题文件不在同一个目录，一个在 theme_rtl ，一个在 theme，所以，在 theme_rtl 目录下，需要对 gulp 进行重新部署。 然后进入 gulpfile.js 位于的 theme_rtl 目录。确定最新修改的 SCSS 已通过 gulp sass 或 gulp sass:watch 命令编译。运行 gulp rtlcss 命令执行 css 文件的 RTL 版本修改任务。编译后的 RTL css 会被输出到 assets 目录. CSS 和 JS 文件的压缩 在命令行下进入 theme 目录。运行 gulp minify 执行 css 和 js 文件压缩任务.压缩后的文件会输出到 html 目录. HTML 格式化 gulp prettify 该命令可以将 HTML 格式化缩进，对于 pre 和 code 两个标签内的内容不进行格式化。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"Metronic","slug":"Metronic","permalink":"https://wsrdadian.github.io/tags/Metronic/"}]},{"title":"没有密码怎么进入系统","slug":"没有密码怎么进入系统","date":"2019-03-08T02:10:58.000Z","updated":"2019-03-08T02:33:14.974Z","comments":true,"path":"2019/03/08/没有密码怎么进入系统/","link":"","permalink":"https://wsrdadian.github.io/2019/03/08/没有密码怎么进入系统/","excerpt":"","text":"很无脑的操作，只需要一个U启 准备工作 一个U盘启动器（平时用来装系统的，我的是 老友 老毛桃也可以） 查找电脑主机型号所对应的 BOIS 系统进入按键 步骤 进入 BIOS ，选择进入 USB 系统 使用密码破解功能，选择你想破解的用户，或者直接破解管理员 关机重新启动，选择管理员登录（或者使用你修改了密码以后的用户） 登录管理员账户后进入控制面板创建新的账户 关机，登录自己的新账户 总结 千万不要让陌生人的U盘接近自己的电脑 做一个U启随身带着以防不时之需","categories":[{"name":"系统","slug":"系统","permalink":"https://wsrdadian.github.io/categories/系统/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://wsrdadian.github.io/tags/Windows/"}]},{"title":"地图离线之瓦片下载-python+PIL","slug":"使用python离线地图","date":"2019-03-06T01:25:54.000Z","updated":"2019-03-15T06:53:41.862Z","comments":true,"path":"2019/03/06/使用python离线地图/","link":"","permalink":"https://wsrdadian.github.io/2019/03/06/使用python离线地图/","excerpt":"","text":"使用python下载瓦片 环境 python3.7 内置pip，使用比较方便 PIL只支持到 python2.7,在3.7之后，使用 pillow 效果相同1pip install Pillow 代码 github链接 按照md文件进行自定义操作 修改了一些代码 gmap_utils.py 文件中ak值换成自己申请的 download_tiles.py 文件 1234query = &quot;qt=tile&amp;x=%d&amp;y=%d&amp;z=%d&amp;styles=%s%s&amp;udt=20190307&quot; % (x, y, zoom, styles, scaler)url = &quot;http://online0.map.bdimg.com/onlinelabel/?&quot; + querypath = &quot;%d_%d_%d_r&quot; % (zoom ,x, y)filename = path + &quot;.png&quot; merge_tiles.py 文件 由于原代码中文件路径和文件名与该文件中的要求不符，所以修改filename使其符合要求 1filename = &quot;tile/%d_%d_%d_%s.%s&quot; % (zoom, x, y, TYPE, ext) 生成的图片加层级标志 1result.save(&quot;map_%d_%s.%s&quot; % (zoom, TYPE, ext)) 仍然存在的一些问题 请求次数过多时，出现10060错误，目前只是重新获取，应该需要对 REQUEST 进行深入研究 级别过高时，合并图片出现内存溢出错误，初步判断为 python 内存设置问题，需继续研究 若合并时内存问题不能解决，高层级可以先获取省级，再逐个将省级合并为国家级，此时应写出新的 python 的图像合成文件","categories":[{"name":"python","slug":"python","permalink":"https://wsrdadian.github.io/categories/python/"}],"tags":[{"name":"百度地图","slug":"百度地图","permalink":"https://wsrdadian.github.io/tags/百度地图/"},{"name":"python","slug":"python","permalink":"https://wsrdadian.github.io/tags/python/"},{"name":"PIL","slug":"PIL","permalink":"https://wsrdadian.github.io/tags/PIL/"}]},{"title":"使用vue.js2.5+cube-ui仿饿了么APP-项目准备工作","slug":"使用vue-js2-5-cube-ui仿饿了么APP-项目准备工作","date":"2019-01-15T08:31:21.000Z","updated":"2019-01-15T11:46:51.891Z","comments":true,"path":"2019/01/15/使用vue-js2-5-cube-ui仿饿了么APP-项目准备工作/","link":"","permalink":"https://wsrdadian.github.io/2019/01/15/使用vue-js2-5-cube-ui仿饿了么APP-项目准备工作/","excerpt":"","text":"进行项目准备，安装 vue、cube-ui 并测试 api 数据接口。 vue 安装 安装vue-cli 12npm install -g @vue/clivue --version 创建项目 1vue create 项目名 选择相应配置 测试项目是否能够成功运行 12cd 项目名npm run serve 访问 http://localhost:8080/ cube-ui安装 cube-ui的 github地址 作为 vue-cli 插件使用 1vue add cube-ui 进行相关配置 请仔细阅读 vue-cli 和 cube-ui 文档 api接口mock 根目录下添加 ./data.json在项目源码中下载文件，下载方法 在 vue.config.js 中添加代码 1234const appData = require(&apos;./data.json&apos;)const seller = appData.sellerconst goods = appData.goodsconst ratings = appData.ratings pluginOptions后添加 12345678910111213141516171819202122devServer: &#123; before(app) &#123; app.get(&apos;/api/seller&apos;,function(req,res) &#123; res.json(&#123; errno: 0, data: seller &#125;) &#125;) app.get(&apos;/api/goods&apos;,function(req,res) &#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;) app.get(&apos;/api/ratings&apos;,function(req,res) &#123; res.json(&#123; errno: 0, data: ratings &#125;) &#125;) &#125; &#125; 运行程序并访问 http://localhost:8080/api/seller 如果显示json内容则正确 为谷歌浏览器安装 jsonview","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wsrdadian.github.io/tags/vue/"},{"name":"cube-ui","slug":"cube-ui","permalink":"https://wsrdadian.github.io/tags/cube-ui/"}]},{"title":"修改配色为小埋色以及图标制作","slug":"修改配色为小埋色以及图标制作","date":"2019-01-14T12:46:27.000Z","updated":"2019-01-14T13:01:49.960Z","comments":true,"path":"2019/01/14/修改配色为小埋色以及图标制作/","link":"","permalink":"https://wsrdadian.github.io/2019/01/14/修改配色为小埋色以及图标制作/","excerpt":"","text":"修改博客配色为小埋色 , 主色是小埋斗篷颜色 , 部分部件是裤子的颜色 , 大部分文字为黑白. less文件/themes/indigo/source/css/_partical/variable.less1234@darkPrimaryColor: #334432; @primaryColor: #f28135; #主色(小埋色)@lightPrimaryColor: #fcddb7; #发色@textPrimaryColor: #fff; 修改头像背景/themes/indigo/source/img/brand.jpg 图标制作 使用ico在线制作工具将图片转为 .ico 格式 将图片放入 themes/indigo/source/img 文件夹中，并修改 themes/indigo 中_config.xml 中 favicon 为 /img/favicon.ico","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wsrdadian.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://wsrdadian.github.io/tags/blog/"}]},{"title":"使用hexo快速建立属于自己的blog","slug":"如使用hexo何¦何使用hexo快建立blog快速","date":"2019-01-14T11:30:25.000Z","updated":"2019-01-14T12:29:25.287Z","comments":true,"path":"2019/01/14/如使用hexo何¦何使用hexo快建立blog快速/","link":"","permalink":"https://wsrdadian.github.io/2019/01/14/如使用hexo何¦何使用hexo快建立blog快速/","excerpt":"","text":"使用HEXO快速搭建个性化BLOG 环境 使用命令行工具 Git 管理和部署代码 安装 Node 并安装 npm 步骤 注册 github 账号并配置 ssh 在github上新建一个项目,注意项目名为 用户名.github.io 使用npm快速安装 hexo 123hexo init //初始化hexocd hexo //进入项目文件npm install //安装依赖包 安装喜欢的 主题 12git clone 主题的下载地址.gitnpm install 主题插件 此博客风格为 indigo 主题安装完成后对 hexo 的根目录下的 _config.yml 进行修改 1234567891011title: 博客标题subtitle: 副标题description: 网站描述language: 语言url: 站点网址(必填,否则会报错)deploy: type: git repo: ssh网址.git branch: master&lt;!--其他视情况填写即可--&gt; 对主题进行个性化配置,修改主题目录下的 _config.yml 生成网页 , 本地预览 12hexo generatehexo server 本地预览网址: http://localhost:4000 新建 blog 1hexo new &quot;文章标题&quot; 在 source/_posts 目录下会生成文章标题.md 123456title: 文章标题date: 2015-07-30 07:56:29 #发表日期，一般不改动categories: 文章分类tags: [github,hexo] 文章标签---正文，使用Markdown语法书写 部署到 github 的项目上 1hexo deploy 部署成功会提示 1[info] Deploy done: git 访问 https://github用户名.github.io 查看自己的博客 常见问题 提示 Cannot read property ‘replace’ of null 错误 ——–&gt; _config.yml 中 url 未填写导致 代码部署未更新 ——–&gt; hexo clean 后执行 hexo deploy 即可 每次部署都需要输入 github 用户名和密码 ———&gt; 检查 _config.yml 中配置的链接是 ssh 还是 https 链接 自定义的样式无效 ——-&gt; _config.yml 中设置 cdn: false","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://wsrdadian.github.io/categories/前端学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wsrdadian.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://wsrdadian.github.io/tags/blog/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-14T08:37:25.599Z","updated":"2019-01-14T08:37:25.599Z","comments":true,"path":"2019/01/14/hello-world/","link":"","permalink":"https://wsrdadian.github.io/2019/01/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}